<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TICPP</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="TICPP/11/11.0.html"><strong aria-hidden="true">1.</strong> 11.References & the Copy-Constructor)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="TICPP/11/11.1.html"><strong aria-hidden="true">1.1.</strong> 11.1C++ 中的指针</a></li><li class="chapter-item expanded "><a href="TICPP/11/11.2.html"><strong aria-hidden="true">1.2.</strong> 11.2C++ 中的引用</a></li><li class="chapter-item expanded "><a href="TICPP/11/11.3.html"><strong aria-hidden="true">1.3.</strong> 11.3拷贝构造函数</a></li><li class="chapter-item expanded "><a href="TICPP/11/11.4.html"><strong aria-hidden="true">1.4.</strong> 11.成员指针</a></li><li class="chapter-item expanded "><a href="TICPP/11/11.5.html"><strong aria-hidden="true">1.5.</strong> 11.Summary</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">TICPP</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="11-references--the-copy-constructor引用和复制构造函数"><a class="header" href="#11-references--the-copy-constructor引用和复制构造函数">11: References &amp; the Copy-Constructor(引用和复制构造函数)</a></h1>
<p><em>引用就像常量指针，编译器会自动取消引用。</em></p>
<p>虽然引用也存在于 <code>Pascal</code> 语言中，但 <code>C++</code> 的引用版本来自 <code>Algol</code> 语言。在 <code>C++</code> 中，引用对于支持操作符重载的语法（参见第 12 章）是必不可少的，但引用也是控制参数传入和传出函数的一种通用便利。</p>
<p>本章将首先简要介绍 <code>C</code> 和 <code>C++</code> 中指针的区别，然后介绍引用。但本章的主要内容将深入探讨一个令新 <code>C++</code> 程序员相当困惑的问题：拷贝构造函数，这是一个特殊的构造函数（需要引用），它可以从现有的同类型对象中创建一个新对象。编译器使用复制构造函数在函数中传递和返回对象值。</p>
<p>最后，有点晦涩难懂的 <code>C++</code> 指针到成员功能也得到了阐明。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="111-pointers-in-cc-中的指针"><a class="header" href="#111-pointers-in-cc-中的指针">11.1 Pointers in C++(C++ 中的指针)</a></h2>
<p>C 语言中的指针与 C++ 语言中的指针最重要的区别在于，C++ 是一种强类型语言。这一点在 <strong>void</strong>* 中表现得尤为突出。C 语言不允许随意将一种类型的指针赋值给另一种类型，但允许通过 <strong>void</strong>* 来实现。因此</p>
<pre><code class="language-cpp">bird* b;
rock* r;
void* v;
v = r;
b = v;
</code></pre>
<p>由于 C 语言的这一 "特性 "允许您悄悄地将任何类型视为其他类型，因此在类型系统中留下了一个大漏洞。C++ 不允许这样做；编译器会给你一条错误信息，而且如果你真的想把一种类型当作另一种类型，你必须通过使用一个 "铸型"（cast）向编译器和读者明确说明（第 3 章介绍了 C++ 改进的 "显式 "铸型语法）。(第 3 章介绍了 C++ 经过改进的 "显式 "转换语法）。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="112-references-in-cc-中的引用"><a class="header" href="#112-references-in-cc-中的引用">11.2 References in C++(C++ 中的引用)</a></h2>
<p><em>reference</em>（<strong>&amp;</strong>）就像一个自动取消引用的常量指针。它通常用于函数参数列表和函数返回值。但你也可以创建一个独立的引用。例如</p>
<pre><code class="language-cpp">//: C11:FreeStandingReferences.cpp
#include &lt;iostream&gt;
using namespace std;
 
// Ordinary free-standing reference:
int y;
int&amp; r = y;
// When a reference is created, it must 
// be initialized to a live object. 
// However, you can also say:
const int&amp; q = 12;  // (1)
// References are tied to someone else's storage:
int x = 0;          // (2)
int&amp; a = x;         // (3)
int main() {
  cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; ", a = " &lt;&lt; a &lt;&lt; endl;
  a++;
  cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; ", a = " &lt;&lt; a &lt;&lt; endl;
} ///:~
</code></pre>
<p>在第(1)行中，编译器分配了一个存储空间，将其初始化为值 12，并将引用与该存储空间绑定。问题的关键在于，任何引用都必须绑定到别人的存储空间上。当你访问引用时，就是在访问该存储空间。因此，如果你写了像(2)和(3)这样的行，那么递增<strong>a</strong>实际上就是递增<strong>x</strong>，如**main( )**所示。再次强调，将引用视为一个漂亮的指针是最简单的方法。这种 "指针 "的一个优点是，你不必担心它是否已被初始化（编译器会强制初始化）以及如何取消引用（编译器会取消引用）。</p>
<p>使用引用有一定的规则：</p>
<ol>
<li>引用必须在创建时初始化。(指针可随时初始化）</li>
<li>引用一旦被初始化为一个对象，就不能更改为指向另一个对象。(指针可以随时指向另一个对象）</li>
<li>不能有 NULL 引用。必须始终能够假定引用连接到一个合法的存储空间。</li>
</ol>
<h3 id="references-in-functions函数中的引用"><a class="header" href="#references-in-functions函数中的引用">References in functions(函数中的引用)</a></h3>
<p>最常见的引用是函数参数和返回值。当引用用作函数参数时，对函数内部引用的任何修改都会导致函数外部参数的改变。当然，你也可以通过传递指针来做同样的事情，但引用的语法更简洁。(如果你愿意，可以把引用看作是一种语法上的便利)</p>
<p>如果从函数中返回引用，就必须像从函数中返回指针一样小心谨慎。当函数返回时，引用所连接的任何内容都不应消失，否则就会指向未知内存。</p>
<p>这里有一个例子：</p>
<pre><code class="language-cpp">//: C11:Reference.cpp
// Simple C++ references

int* f(int* x) {
  (*x)++;
  return x; // Safe, x is outside this scope
}

int&amp; g(int&amp; x) {
  x++; // Same effect as in f()
  return x; // Safe, outside this scope
}

int&amp; h() {
  int q;
//!  return q;  // Error
  static int x;
  return x; // Safe, x lives outside this scope
}

int main() {
  int a = 0;
  f(&amp;a); // Ugly (but explicit)
  g(a);  // Clean (but hidden)
} ///:~
</code></pre>
<p>对 <strong>f( )</strong> 的调用没有使用引用那么方便和简洁，但显然传递了一个地址。在<strong>g( )</strong> 的调用中，地址正在传递（通过引用），但你看不到。</p>
<h4 id="const-references"><a class="header" href="#const-references">const references</a></h4>
<p><strong>Reference.cpp</strong>中的引用参数只有在参数为非<strong>const</strong>对象时才起作用。如果它是一个<strong>const</strong>对象，函数 <strong>g( )</strong> 将不接受该参数，这实际上是一件好事，因为函数_确实_修改了外部参数。如果知道函数将尊重对象的<strong>const</strong>性，那么将参数作为<strong>const</strong>引用将允许函数在所有情况下使用。这意味着，对于内置类型，函数不会修改参数，而对于用户定义类型，函数只会调用<strong>const</strong>成员函数，不会修改任何<strong>public</strong>数据成员。</p>
<p>在函数参数中使用 <strong>const</strong> 引用尤为重要，因为您的函数可能会收到一个临时对象。该对象可能是作为另一个函数的返回值创建的，也可能是由函数用户明确创建的。临时对象总是<strong>const</strong>的，因此如果不使用<strong>const</strong>引用，编译器就不会接受该参数。举个简单的例子</p>
<pre><code class="language-cpp">//: C11:ConstReferenceArguments.cpp
// Passing references as const

void f(int&amp;) {}
void g(const int&amp;) {}

int main() {
//!  f(1); // Error
  g(1);
} ///:~
</code></pre>
<p>调用 <strong>f(1)</strong> 会导致编译时错误，因为编译器必须首先创建一个引用。为此，编译器必须为一个 <strong>int</strong> 分配存储空间，将其初始化为 1，并产生与引用绑定的地址。存储空间必须是<strong>常数</strong>，因为改变存储空间是没有意义的--你将永远无法再使用它。对于所有临时对象，你都必须做出同样的假设：它们是不可访问的。编译器会在你更改这些数据时告诉你，这是很有价值的，因为这样做的结果就是丢失信息。</p>
<h4 id="pointer-references指针引用"><a class="header" href="#pointer-references指针引用">Pointer references(指针引用)</a></h4>
<p>在 C 语言中，如果要修改指针的_contents_（内容），而不是指针所指向的内容，函数声明就会如下所示：</p>
<pre><code class="language-cpp">void f(int**);
</code></pre>
<p>而且在传入指针时，必须获取指针的地址：</p>
<pre><code class="language-cpp">&gt; int i = 47;
&gt; int* ip = &amp;i;
&gt; f(&amp;ip); 
</code></pre>
<p>C++ 中的引用语法更加简洁。函数参数变成了对指针的引用，你不再需要获取该指针的地址。因此</p>
<pre><code class="language-cpp">&gt; //: C11:ReferenceToPointer.cpp
&gt; #include &lt;iostream&gt;
&gt; using namespace std;
&gt; 
&gt; void increment(int*&amp; i) { i++; }
&gt; 
&gt; int main() {
&gt;   int* i = 0;
&gt;   cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; endl;
&gt;   increment(i);
&gt;   cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; endl;
&gt; } ///:~
</code></pre>
<p>通过运行这个程序，你可以证明指针是递增的，而不是指针指向的内容。</p>
<h3 id="argument-passing-guidelines--无恰当翻译"><a class="header" href="#argument-passing-guidelines--无恰当翻译">Argument-passing guidelines  (无恰当翻译)</a></h3>
<p>向函数传递参数时，您通常的习惯应该是通过 <strong>const</strong> 引用来传递。虽然起初这似乎只是一个效率问题（而且在设计和编译程序时，你通常并不关心效率问题），但实际上还有更重要的问题：正如你在本章剩余的内容中所看到的，要通过值传递一个对象，需要一个拷贝构造函数，而这并不总是可用的。</p>
<p>对于这样一个简单的习惯，可以节省大量的效率：通过值传递参数需要调用构造函数和析构函数，但如果你不打算修改参数，那么通过 <strong>const</strong> 引用传递参数只需要在堆栈中推送一个地址。</p>
<p>事实上，几乎只有一种情况下传递地址是不可取的，那就是当你要对一个对象造成严重破坏时，按值传递是唯一安全的方法（而不是修改外部对象，这通常不是调用者所期望的）。这就是下一节的主题。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="113-the-copy-constructor拷贝构造函数"><a class="header" href="#113-the-copy-constructor拷贝构造函数">11.3 The copy-constructor(拷贝构造函数)</a></h2>
<p>现在，您已经了解了 C++ 中引用的基础知识，可以开始处理语言中更容易混淆的概念之一：复制构造函数，通常称为 <strong>X(X&amp;)</strong> （"X 的 X ref"）。这个构造函数对于在函数调用过程中控制用户定义类型的值传递和返回至关重要。事实上，它是如此重要，以至于编译器会自动合成一个拷贝构造函数，如果你自己不提供的话.</p>
<h3 id="passing--returning-by-value按值传递和返回"><a class="header" href="#passing--returning-by-value按值传递和返回">Passing &amp; returning by value(按值传递和返回)</a></h3>
<p>要理解复制构造函数的必要性，可以考虑一下 C 语言在函数调用过程中处理按值传递和返回变量的方式。如果你声明了一个函数并进行了函数调用、</p>
<pre><code class="language-cpp">&gt; int f(int x, char c);
&gt; int g = f(a, b);
</code></pre>
<p>编译器如何知道如何传递和返回这些变量？它就是知道！编译器必须处理的类型范围非常小--<strong>char</strong>、<strong>int</strong>、<strong>float</strong>、<strong>double</strong>以及它们的变体--因此编译器内置了这些信息。</p>
<p>如果你知道如何用编译器生成汇编代码，并确定调用 <strong>f( )</strong> 函数所生成的语句，你就会得到类似的结果：</p>
<pre><code class="language-cpp">&gt; push  b
&gt; push  a
&gt; call  f()
&gt; add  sp,4
&gt; mov  g, register a
</code></pre>
<p>为了使代码具有通用性，<strong>b</strong> 和 <strong>a</strong> 的表达式将根据变量是全局变量（在这种情况下，它们将是 <strong>_ b</strong> 和 <strong>_ a</strong>）还是局部变量（编译器将从堆栈指针中索引它们）而有所不同。对于 <strong>g</strong> 的表达式也是如此。调用 <strong>f( )</strong> 的外观取决于您的名称装饰方案，而 "寄存器 a "则取决于 CPU 寄存器在汇编器中的命名方式。不过，代码背后的逻辑是相同的.</p>
<p>在 C 和 C++ 中，参数首先从右向左推入堆栈，然后进行函数调用。调用代码负责将参数从堆栈中清除（这也是 <strong>add sp,4</strong> 的原因）。但请注意，如果要按值传递参数，编译器只需在堆栈中推送副本即可--编译器知道参数有多大，推送这些参数可以准确地复制参数。</p>
<p><strong>f( )</strong> 的返回值放在寄存器中。同样，编译器知道关于返回值类型的所有信息，因为该类型是内置在语言中的，所以编译器可以通过将其放入寄存器来返回值。对于 C 语言中的基元数据类型，复制值的位就相当于复制对象。</p>
<h4 id="passing--returning-large-objects--传递和返回大型对象"><a class="header" href="#passing--returning-large-objects--传递和返回大型对象">Passing &amp; returning large objects  (传递和返回大型对象)</a></h4>
<p>但现在考虑一下用户定义类型。如果你创建了一个类，并想通过值传递该类的一个对象，那么编译器该如何知道该怎么做呢？这不是编译器内置的类型，而是你创建的类型。</p>
<p>要研究这个问题，可以从一个简单的结构开始，这个结构显然太大，无法用寄存器返回：</p>
<pre><code class="language-cpp">&gt; //: C11:PassingBigStructures.cpp
&gt; struct Big {
&gt;   char buf[100];
&gt;   int i;
&gt;   long d;
&gt; } B, B2;
&gt; 
&gt; Big bigfun(Big b) {
&gt;   b.i = 100; // Do something to the argument
&gt;   return b;
&gt; }
&gt; 
&gt; int main() {
&gt;   B2 = bigfun(B);
&gt; } ///:~
</code></pre>
<p>由于大多数编译器都使用 "辅助 "函数，而不是将所有功能内联，因此解码汇编输出在这里要复杂一些。在(<strong>main</strong>)()中，对(<strong>bigfun()</strong>)的调用如你猜测的那样开始--  <strong>B</strong>的全部内容被推入堆栈。(在这里，你可能会看到一些编译器将 <strong>Big</strong> 的地址及其大小载入寄存器，然后调用辅助函数将 <strong>Big</strong> 推入堆栈）。</p>
<p>在前面的代码片段中，调用函数之前只需要将参数推入堆栈。然而，在<strong>PassingBigStructures.cpp</strong>中，你会看到一个额外的操作：在调用之前，<strong>B2</strong>的地址被推入，尽管它显然不是一个参数。要理解这里发生了什么，你需要了解编译器在进行函数调用时的限制条件。</p>
<h4 id="function-call-stack-frame函数调用堆栈框架"><a class="header" href="#function-call-stack-frame函数调用堆栈框架">Function-call stack frame(函数调用堆栈框架)</a></h4>
<p>编译器为函数调用生成代码时，首先会将所有参数推入堆栈，然后进行调用。在函数内部，生成的代码会将堆栈指针向下移动更远，以便为函数的局部变量提供存储空间。(这里的 "向下 "是相对的，机器可能会在推栈过程中增减栈指针）。但是在汇编语言 CALL 时，CPU 会将函数调用的地址推送到程序代码中，因此汇编语言 RETURN 可以使用该地址返回调用点。这个地址当然非常重要，因为如果没有它，你的程序就会完全丢失。下面是函数 CALL 和分配局部变量存储空间后的堆栈框架：</p>
<div style = "text-align: center;">
<img src="TICPP/11/D:\mbook\TICPP\src\TICPP\schema\11\TV1.gif" alt="图片alt" title="图片title"></div>
<p>为函数其余部分生成的代码希望内存完全按照这种方式布局，这样它就可以仔细地从函数参数和局部变量中挑选，而不会触及返回地址。在函数调用的过程中，函数所使用的所有内存块都被称为_函数框架_。</p>
<p>你可能会认为尝试在堆栈上返回值是合理的。编译器可以简单地将其推入，函数可以返回一个偏移量，以指示返回值在堆栈中的起始位置。</p>
<h4 id="re-entrancy重定向"><a class="header" href="#re-entrancy重定向">Re-entrancy(重定向)</a></h4>
<p>之所以会出现这个问题，是因为 C 和 C++ 中的函数支持中断；也就是说，这两种语言是_重入的_。它们还支持递归函数调用。这意味着在程序执行的任何时候都可能发生中断而不会中断程序。当然，编写中断服务例程（ISR）的人要负责保存和恢复 ISR 中使用的所有寄存器，但如果 ISR 需要使用堆栈中的任何内存，这必须是一件安全的事情。(可以将 ISR 视为一个普通函数，没有参数，返回值为 <strong>void</strong> ，用于保存和恢复 CPU 状态。ISR 函数调用由某些硬件事件触发，而不是在程序中明确调用）。</p>
<p>现在想象一下，如果一个普通函数试图返回堆栈上的值，会发生什么。你不能触及堆栈中返回地址上方的任何部分，因此函数必须将值推到返回地址下方。但在执行汇编语言 RETURN 时，堆栈指针必须指向返回地址（或返回地址的正下方，具体取决于机器），因此在执行 RETURN 之前，函数必须将堆栈指针向上移动，从而清空所有局部变量。如果你试图返回堆栈中低于返回地址的值，那么此时你就会变得很脆弱，因为中断可能会出现。ISR 会向下移动堆栈指针，以保存其返回地址和局部变量，并覆盖你的返回值。</p>
<p>为了解决这个问题，调用者_可以_负责在调用函数之前为返回值在堆栈上分配额外的存储空间。然而，C 语言并不是这样设计的，C++ 必须与之兼容。我们很快就会看到，C++ 编译器使用了一种更有效的方案。</p>
<p>你的下一个想法可能是在某个全局数据区中返回值，但这也行不通。重入意味着任何函数都可以成为任何其他函数的中断例程，包括你当前所在的函数。因此，如果将返回值放在全局区域中，可能会返回到同一函数中，从而覆盖该返回值。同样的逻辑也适用于递归。</p>
<p>唯一安全的返回值存放位置是寄存器，因此又回到了寄存器容量不足以存放返回值时该怎么办的问题。答案是将返回值的目标地址作为函数参数之一推入堆栈，然后让函数直接将返回信息复制到目标地址。这不仅能解决所有问题，而且效率更高。这也是<strong>PassingBigStructures.cpp</strong>中，编译器在<strong>main( )</strong> 中调用<strong>bigfun()</strong> 之前推送<strong>B2</strong>地址的原因。如果查看<strong>bigfun( )</strong> 的汇编输出，就会发现它期望得到这个隐藏参数，并在函数内部执行复制到目标地址的操作。</p>
<h4 id="bitcopy-versus-initialization--bitcopy-与初始化"><a class="header" href="#bitcopy-versus-initialization--bitcopy-与初始化">Bitcopy versus initialization  (Bitcopy 与初始化)</a></h4>
<p>到目前为止，一切顺利。我们有了一个传递和返回大型简单结构的可行过程。但请注意，你所拥有的只是一种将比特从一个地方复制到另一个地方的方法，这对于 C 语言看待变量的原始方式来说当然是行之有效的。但在 C++ 中，对象可能比比特补丁复杂得多；它们是有意义的。这种意义可能不会对比特的复制做出很好的反应。</p>
<p>请看一个简单的例子：一个类知道在同一时间有多少个与其类型相同的对象存在。通过第 10 章的学习，我们知道实现这一目的的方法是加入一个 <strong>static</strong> 数据成员：</p>
<pre><code class="language-cpp"> //: C11:HowMany.cpp
&gt; // A class that counts its objects
&gt; #include &lt;fstream&gt;
&gt; #include &lt;string&gt;
&gt; using namespace std;
&gt; ofstream out("HowMany.out");
&gt; 
&gt; class HowMany {
&gt;   static int objectCount;
&gt; public:
&gt;   HowMany() { objectCount++; }
&gt;   static void print(const string&amp; msg = "") {
&gt;     if(msg.size() != 0) out &lt;&lt; msg &lt;&lt; ": ";
&gt;     out &lt;&lt; "objectCount = "
&gt;          &lt;&lt; objectCount &lt;&lt; endl;
&gt;   }
&gt;   ~HowMany() {
&gt;     objectCount--;
&gt;     print("~HowMany()");
&gt;   }
&gt; };
&gt; 
&gt; int HowMany::objectCount = 0;
&gt; 
&gt; // Pass and return BY VALUE:
&gt; HowMany f(HowMany x) {
&gt;   x.print("x argument inside f()");
&gt;   return x;
&gt; }
&gt; 
&gt; int main() {
&gt;   HowMany h;
&gt;   HowMany::print("after construction of h");
&gt;   HowMany h2 = f(h);
&gt;   HowMany::print("after call to f()");
&gt; } ///:~
</code></pre>
<p>类 <strong>HowMany</strong> 包含一个 <strong>static</strong> <strong>int objectCount</strong> 和一个 <strong>static</strong> 成员函数 <strong>print( )</strong> 用于报告 <strong>objectCount</strong> 的值，以及一个可选的消息参数。每次创建对象时，构造函数都会递增计数，而析构函数则会递减计数。</p>
<p>然而，输出结果却不尽如人意：</p>
<pre><code class="language-cpp">&gt; after construction of h: objectCount = 1
&gt; x argument inside f(): objectCount = 1
&gt; ~HowMany(): objectCount = 0
&gt; after call to f(): objectCount = 0
&gt; ~HowMany(): objectCount = -1
&gt; ~HowMany(): objectCount = -2
</code></pre>
<p>创建<strong>h</strong>后，对象数是一个，这没有问题。但在调用 <strong>f( )</strong> 后，由于 <strong>h2</strong> 现在也在作用域中，因此对象计数应该是 2。但结果却是零，这说明出了大问题。最后的两个析构函数使对象计数变为负数，这也证实了这一点，而这是绝对不应该发生的。</p>
<p>请看 <strong>f()</strong> 内部的一点，它发生在参数通过值传递之后。这意味着原始对象<strong>h</strong>存在于函数框架之外，而在函数框架内还有一个额外的对象，即通过值传递的副本。然而，参数的传递使用了 C 语言最原始的位拷贝概念，而 C++ 的 <strong>HowMany</strong> 类需要真正的初始化来保持其完整性，因此默认的位拷贝无法产生预期的效果。</p>
<p>当本地对象在调用 <strong>f( )</strong> 结束时退出作用域，析构函数被调用，析构函数会递减 <strong>对象计数</strong>，因此在函数外部，<strong>对象计数</strong>为零。<strong>h2</strong> 的创建也是通过位拷贝完成的，因此也没有调用构造函数，当 <strong>h</strong> 和 <strong>h2</strong> 退出作用域时，它们的析构函数会导致 <strong>objectCount</strong> 为负值。</p>
<h3 id="copy-construction复制构造"><a class="header" href="#copy-construction复制构造">Copy-construction(复制构造)</a></h3>
<p>出现这个问题的原因是编译器对如何从现有对象创建_新对象_做出了假设。当您通过值传递一个对象时，您会从一个现有对象（即函数框架外的原始对象）创建一个新对象，即函数框架内的传递对象。当从函数返回一个对象时，通常也是如此。在表达式</p>
<pre><code class="language-cpp">&gt; HowMany h2 = f(h);
</code></pre>
<p><strong>h2</strong>是一个先前未构造的对象，它是根据<strong>f( )</strong> 的返回值创建的，因此又是从一个现有对象创建了一个新对象。</p>
<p>编译器的假设是，你希望使用位拷贝来执行创建，在很多情况下这可能行得通，但在<strong>HowMany</strong>中却行不通，因为初始化的意义远不止拷贝这么简单。另一个常见的例子是，如果类中包含指针--它们指向什么？</p>
<p>幸运的是，您可以干预这一过程，防止编译器进行位拷贝。为此，你可以定义自己的函数，当编译器需要从现有对象中创建一个新对象时，就可以使用这个函数。从逻辑上讲，你正在创建一个新对象，所以这个函数是一个构造函数，从逻辑上讲，这个构造函数的唯一参数与你正在构造的对象有关。但是，这个对象不能通过值传递给构造函数，因为你正在尝试_定义_处理通过值传递的函数，而且从语法上讲，传递指针是没有意义的，因为毕竟你是从一个现有对象创建新对象的。这时，引用就派上用场了，你可以获取源对象的引用。这个函数被称为_copy-constructor_，通常被称为 <strong>X(X&amp;)</strong>，这是它在一个名为 <strong>X</strong>的类中的外观。</p>
<p>如果创建了复制构造函数，编译器在从现有对象创建新对象时将不会执行位拷贝。它会一直调用你的复制构造函数。因此，如果不创建拷贝构造函数，编译器会做一些合理的事情，但你可以选择完全控制整个过程。</p>
<p>现在可以在 <strong>HowMany.cpp</strong>中解决这个问题了：</p>
<pre><code class="language-cpp">&gt; //: C11:HowMany2.cpp
&gt; // The copy-constructor
&gt; #include &lt;fstream&gt;
&gt; #include &lt;string&gt;
&gt; using namespace std;
&gt; ofstream out("HowMany2.out");
&gt; 
&gt; class HowMany2 {
&gt;   string name; // Object identifier
&gt;   static int objectCount;
&gt; public:
&gt;   HowMany2(const string&amp; id = "") : name(id) {
&gt;     ++objectCount;
&gt;     print("HowMany2()");
&gt;   }
&gt;   ~HowMany2() {
&gt;     --objectCount;
&gt;     print("~HowMany2()");
&gt;   }
&gt;   // The copy-constructor:
&gt;   HowMany2(const HowMany2&amp; h) : name(h.name) {
&gt;     name += " copy";
&gt;     ++objectCount;
&gt;     print("HowMany2(const HowMany2&amp;)");
&gt;   }
&gt;   void print(const string&amp; msg = "") const {
&gt;     if(msg.size() != 0) 
&gt;       out &lt;&lt; msg &lt;&lt; endl;
&gt;     out &lt;&lt; '\t' &lt;&lt; name &lt;&lt; ": "
&gt;         &lt;&lt; "objectCount = "
&gt;         &lt;&lt; objectCount &lt;&lt; endl;
&gt;   }
&gt; };
&gt; 
&gt; int HowMany2::objectCount = 0;
&gt; 
&gt; // Pass and return BY VALUE:
&gt; HowMany2 f(HowMany2 x) {
&gt;   x.print("x argument inside f()");
&gt;   out &lt;&lt; "Returning from f()" &lt;&lt; endl;
&gt;   return x;
&gt; }
&gt; 
&gt; int main() {
&gt;   HowMany2 h("h");
&gt;   out &lt;&lt; "Entering f()" &lt;&lt; endl;
&gt;   HowMany2 h2 = f(h);
&gt;   h2.print("h2 after call to f()");
&gt;   out &lt;&lt; "Call f(), no return value" &lt;&lt; endl;
&gt;   f(h);
&gt;   out &lt;&lt; "After call to f()" &lt;&lt; endl;
&gt; } ///:~
</code></pre>
<p>为了让你更清楚地了解发生了什么，这里加入了一些新的变化。首先，在打印有关对象的信息时，<strong>字符串</strong> <strong>name</strong>将充当对象的标识符。在构造函数中，你可以输入一个标识符字符串（通常是对象的名称），然后使用<strong>string</strong>构造函数将其复制到<strong>name</strong>中。默认<code>= ""</code> 会创建一个空 <strong>字符串</strong>。与之前一样，构造函数会递增<strong>objectCount</strong>，而析构函数则会递减。</p>
<p>接下来是复制构造函数，<strong>HowMany2(const HowMany2&amp;)</strong>。拷贝构造函数只能从现有对象创建一个新对象，因此现有对象的名称会被拷贝到 <strong>name</strong>，后面跟着 "拷贝 "一词，这样你就能看到它是从哪里来的了。如果你仔细观察，就会发现构造函数初始化列表中的<strong>name(h.name)</strong> 调用实际上是在调用<strong>string</strong>复制构造函数。</p>
<p>在复制构造函数中，对象计数会递增，就像在普通构造函数中一样。这意味着在按值传递和返回时，你将获得准确的对象计数。</p>
<p>对 <strong>print( )</strong> 函数进行了修改，以打印出一条信息、对象标识符和对象计数。现在，该函数必须访问特定对象的<strong>名称</strong>数据，因此不再是<strong>静态</strong>成员函数。</p>
<p>在 <strong>main()</strong> 内部，您可以看到对 <strong>f( )</strong> 的第二次调用。不过，这次调用使用了 C 语言常用的忽略返回值的方法。既然你已经知道返回值是如何返回的（即函数内部的代码处理返回过程，将结果放入一个目标地址中，该地址作为隐藏参数传递），你可能会想知道当返回值被忽略时会发生什么。程序的输出会给我们一些启示。</p>
<p>在显示输出结果之前，这里有一个使用 iostreams 为任何文件添加行号的小程序：</p>
<pre><code class="language-cpp">&gt; //: C11:Linenum.cpp
&gt; //{T} Linenum.cpp
&gt; // Add line numbers
&gt; #include "../require.h"
&gt; #include &lt;vector&gt;
&gt; #include &lt;string&gt;
&gt; #include &lt;fstream&gt;
&gt; #include &lt;iostream&gt;
&gt; #include &lt;cmath&gt;
&gt; using namespace std;
&gt; 
&gt; int main(int argc, char* argv[]) {
&gt;   requireArgs(argc, 1, "Usage: linenum file\n"
&gt;     "Adds line numbers to file");
&gt;   ifstream in(argv[1]);
&gt;   assure(in, argv[1]);
&gt;   string line;
&gt;   vector&lt;string&gt; lines;
&gt;   while(getline(in, line)) // Read in entire file
&gt;     lines.push_back(line);
&gt;   if(lines.size() == 0) return 0;
&gt;   int num = 0;
&gt;   // Number of lines in file determines width:
&gt;   const int width = 
&gt;     int(log10((double)lines.size())) + 1;
&gt;   for(int i = 0; i &lt; lines.size(); i++) {
&gt;     cout.setf(ios::right, ios::adjustfield);
&gt;     cout.width(width);
&gt;     cout &lt;&lt; ++num &lt;&lt; ") " &lt;&lt; lines[i] &lt;&lt; endl;
&gt;   }
&gt; } ///:~
</code></pre>
<p>整个文件会被读入一个<code>vector &lt;string&gt;</code>中，使用的代码与本书前面的代码相同。在打印行号时，我们希望所有的行都能相互对齐，这就需要调整文件的行数，使行号的宽度保持一致。我们可以使用 <strong>vector::size( )</strong> 方便地确定行数，但我们真正需要知道的是文件是否超过 10 行、100 行、1000 行等。如果取文件行数的对数（以 10 为底），截断为一个 <strong>整数</strong>，然后在该值上加 1，就能得出行数的最大宽度。</p>
<p>你会发现在 <strong>for</strong> 循环内有几个奇怪的调用：<strong>setf( )</strong> 和 <strong>width( )</strong> 。这些是<strong>流</strong>调用，允许你控制输出的对齐方式和宽度。不过，每次输出一行时都必须调用它们，这也是它们位于 <strong>for</strong> 循环内部的原因。本书第 2 卷有一整章解释 iostreams，将告诉你更多关于这些调用以及控制 iostreams 的其他方法。</p>
<p>将 <strong>Linenum.cpp</strong>应用于 <strong>HowMany2.out</strong>，结果是</p>
<pre><code class="language-cpp">&gt;  1) HowMany2()
&gt;  2)   h: objectCount = 1
&gt;  3) Entering f()
&gt;  4) HowMany2(const HowMany2&amp;)
&gt;  5)   h copy: objectCount = 2
&gt;  6) x argument inside f()
&gt;  7)   h copy: objectCount = 2
&gt;  8) Returning from f()
&gt;  9) HowMany2(const HowMany2&amp;)
&gt; 10)   h copy copy: objectCount = 3
&gt; 11) ~HowMany2()
&gt; 12)   h copy: objectCount = 2
&gt; 13) h2 after call to f()
&gt; 14)   h copy copy: objectCount = 2
&gt; 15) Call f(), no return value
&gt; 16) HowMany2(const HowMany2&amp;)
&gt; 17)   h copy: objectCount = 3
&gt; 18) x argument inside f()
&gt; 19)   h copy: objectCount = 3
&gt; 20) Returning from f()
&gt; 21) HowMany2(const HowMany2&amp;)
&gt; 22)   h copy copy: objectCount = 4
&gt; 23) ~HowMany2()
&gt; 24)   h copy: objectCount = 3
&gt; 25) ~HowMany2()
&gt; 26)   h copy copy: objectCount = 2
&gt; 27) After call to f()
&gt; 28) ~HowMany2()
&gt; 29)   h copy copy: objectCount = 1
&gt; 30) ~HowMany2()
&gt; 31)   h: objectCount = 0
</code></pre>
<p>正如你所预料的，首先发生的是调用<strong>h</strong>的正常构造函数，将对象计数递增到 1。但是，当输入 <strong>f( )</strong> 时，编译器会悄悄调用复制构造函数来执行逐值传递。在 <strong>f( )</strong> 的函数框架内创建了一个新对象，它是 <strong>h</strong> 的副本（因此称为 "h 副本"），因此对象数变成了两个，这是复制构造函数的功劳。</p>
<p>第八行表示从 <strong>f( )</strong> 返回的开始。但是，在局部变量 "h copy "被销毁（在函数结束时退出作用域）之前，它必须被复制到返回值中，而返回值恰好是 <strong>h2</strong>。一个先前未构造的对象（<strong>h2</strong>）是从一个现有对象（<strong>f( )</strong> 内的局部变量）中创建的，因此在第九行中当然要再次使用复制构造函数。现在，<strong>h2</strong> 的标识符名称变成了 "h copy copy"，因为它是从 <strong>f()</strong> 内部的本地对象拷贝过来的。对象返回后，在函数结束前，对象计数暂时变为 3，但随后本地对象 "h copy "被销毁。在第 13 行完成对 <strong>f( )</strong> 的调用后，只有两个对象，即 <strong>h</strong> 和 <strong>h2</strong>，可以看到 <strong>h2</strong> 最终确实成为了 "h copy 副本"。</p>
<h4 id="temporary-objects-临时对象"><a class="header" href="#temporary-objects-临时对象">Temporary objects (临时对象)</a></h4>
<p>第 15 行开始调用 <strong>f(h)</strong>，这次忽略了返回值。从第 16 行可以看到，与之前一样，拷贝构造函数被调用来传递参数。此外，第 21 行显示，与之前一样，拷贝构造函数被调用以获取返回值。但是，拷贝构造函数必须有一个地址作为它的目标地址（一个<strong>this</strong>指针）。这个地址从何而来？</p>
<p>原来，只要编译器需要一个临时对象来正确评估表达式，它就能创建一个临时对象。在本例中，编译器创建了一个你根本看不到的临时对象，作为 <strong>f( )</strong> 被忽略的返回值的目的地。这个临时对象的生命周期越短越好，这样就不会出现临时对象堆积如山、等待销毁、占用宝贵资源的情况。在某些情况下，临时对象可能会被立即传递给另一个函数，但在这种情况下，函数调用后就不需要它了，所以一旦函数调用结束，调用本地对象的析构函数（第 23 和 24 行），临时对象就会被销毁（第 25 和 26 行）。</p>
<p>最后，在第 28-31 行中，<strong>h2</strong> 对象被销毁，随后<strong>h</strong> 也被销毁，对象计数正确归零。</p>
<h3 id="default-copy-constructor默认复制构造函数"><a class="header" href="#default-copy-constructor默认复制构造函数">Default copy-constructor(默认复制构造函数)</a></h3>
<p>由于拷贝构造函数实现了按值传递和按值返回，因此编译器必须为您创建一个简单结构的拷贝构造函数，这实际上与 C 语言中的做法相同。</p>
<p>当涉及到更复杂的类型时，如果不创建一个拷贝构造函数，C++ 编译器仍会自动创建一个拷贝构造函数。但是，位拷贝同样没有意义，因为它不一定能实现正确的含义。</p>
<p>下面的例子可以说明编译器采用的更智能的方法。假设你创建了一个由多个现有类的对象组成的新类。这就是所谓的 "组合"，也是利用现有类创建新类的方法之一。现在，让我们扮演一个天真的用户，他正试图通过这种方法创建一个新类来快速解决问题。你不了解拷贝构造函数，所以你不会创建拷贝构造函数。示例演示了编译器在为新类创建默认复制构造函数时的操作：</p>
<pre><code class="language-cpp">&gt; //: C11:DefaultCopyConstructor.cpp
&gt; // Automatic creation of the copy-constructor
&gt; #include &lt;iostream&gt;
&gt; #include &lt;string&gt;
&gt; using namespace std;
&gt; 
&gt; class WithCC { // With copy-constructor
&gt; public:
&gt;   // Explicit default constructor required:
&gt;   WithCC() {}
&gt;   WithCC(const WithCC&amp;) {
&gt;     cout &lt;&lt; "WithCC(WithCC&amp;)" &lt;&lt; endl;
&gt;   }
&gt; };
&gt; 
&gt; class WoCC { // Without copy-constructor
&gt;   string id;
&gt; public:
&gt;   WoCC(const string&amp; ident = "") : id(ident) {}
&gt;   void print(const string&amp; msg = "") const {
&gt;     if(msg.size() != 0) cout &lt;&lt; msg &lt;&lt; ": ";
&gt;     cout &lt;&lt; id &lt;&lt; endl;
&gt;   }
&gt; };
&gt; 
&gt; class Composite {
&gt;   WithCC withcc; // Embedded objects
&gt;   WoCC wocc;
&gt; public:
&gt;   Composite() : wocc("Composite()") {}
&gt;   void print(const string&amp; msg = "") const {
&gt;     wocc.print(msg);
&gt;   }
&gt; };
&gt; 
&gt; int main() {
&gt;   Composite c;
&gt;   c.print("Contents of c");
&gt;   cout &lt;&lt; "Calling Composite copy-constructor"
&gt;        &lt;&lt; endl;
&gt;   Composite c2 = c;  // Calls copy-constructor
&gt;   c2.print("Contents of c2");
&gt; } ///:~
</code></pre>
<p>类 <strong>WithCC</strong> 包含一个复制构造函数，该构造函数只是宣布它已被调用，这就带来了一个有趣的问题。在<strong>Composite</strong>类中，<strong>WithCC</strong>的对象是使用默认构造函数创建的。如果<strong>WithCC</strong>中没有任何构造函数，编译器就会自动创建一个默认构造函数，在这种情况下什么也做不了。但是，如果您添加了一个复制构造函数，您就告诉了编译器您将处理构造函数的创建，因此编译器将不再为您创建默认构造函数，除非您像<strong>WithCC</strong>那样显式地创建默认构造函数，否则编译器将会抱怨.</p>
<p>类 <strong>WoCC</strong> 没有复制构造函数，但它的构造函数会在内部 <strong>string</strong> 中存储一条信息，可以使用 <strong>print( )</strong> 打印出来。这个构造函数在<strong>Composite</strong>的构造函数初始化列表中被明确调用（第 8 章简要介绍，第 14 章全面介绍）。这样做的原因稍后会显现出来。</p>
<p>类 <strong>Composite</strong> 的成员对象包括 <strong>WithCC</strong> 和 <strong>WoCC</strong>（注意嵌入对象 <strong>wocc</strong> 必须在构造函数初始化列表中初始化），但没有明确定义的复制构造函数。不过，在 <strong>main( )</strong> 中，使用定义中的复制构造函数创建了一个对象：</p>
<pre><code class="language-cpp">&gt; Composite c2 = c;
</code></pre>
<p>编译器会自动创建<strong>Composite</strong>的拷贝构造函数，程序的输出会显示创建的方式：</p>
<pre><code class="language-cpp">&gt; Contents of c: Composite()
&gt; Calling Composite copy-constructor
&gt; WithCC(WithCC&amp;)
&gt; Contents of c2: Composite()
</code></pre>
<p>要为使用组合（以及第 14 章介绍的继承）的类创建拷贝构造函数，编译器会递归调用所有成员对象和基类的拷贝构造函数。也就是说，如果成员对象还包含另一个对象，它的复制构造函数也会被调用。因此，在本例中，编译器调用了 <strong>WithCC</strong> 的拷贝构造函数。输出结果显示了该构造函数被调用。由于 <strong>WoCC</strong> 没有拷贝构造函数，编译器为它创建了一个只执行位拷贝的构造函数，并在 <strong>Composite</strong> 的拷贝构造函数中调用。main 中对 <strong>Composite::print( )</strong> 的调用说明了这一点，因为 <strong>c2.wocc</strong> 的内容与 <strong>c.wocc</strong> 的内容完全相同。编译器合成拷贝构造函数的过程称为_memberwise initialization_（成员初始化）。</p>
<p>最好是创建自己的复制构造函数，而不是让编译器代劳。这样可以确保它在你的控制之下。</p>
<h3 id="alternatives-to-copy-construction复制构建的替代方案"><a class="header" href="#alternatives-to-copy-construction复制构建的替代方案">Alternatives to copy-construction(复制构建的替代方案)</a></h3>
<p>说到这里，你可能会头晕目眩，你可能会想，如果不知道复制构造函数，你怎么可能写出一个能正常工作的类呢？但是请记住：只有当你要通过值传递类的对象时，你才需要拷贝构造函数。如果这种情况从未发生过，那么就不需要拷贝构造函数。</p>
<h4 id="preventing-pass-by-value防止逐值传递"><a class="header" href="#preventing-pass-by-value防止逐值传递">Preventing pass-by-value(防止逐值传递)</a></h4>
<p>"但是，"你说，"如果我不创建一个复制构造函数，编译器就会为我创建一个。那我怎么知道对象永远不会以值传递呢？</p>
<p>防止逐值传递有一个简单的方法：声明一个<strong>私有</strong>的复制构造函数。你甚至不需要创建定义，除非你的某个成员函数或<strong>友</strong>函数需要执行逐值传递。如果用户试图按值传递或返回对象，编译器将产生一条错误信息，因为拷贝构造函数是<strong>私有</strong>的。编译器无法再创建默认的拷贝构造函数，因为您已明确声明您将接管这项工作。</p>
<p>这里有一个例子：</p>
<pre><code class="language-cpp">&gt; //: C11:NoCopyConstruction.cpp
&gt; // Preventing copy-construction
&gt; 
&gt; class NoCC {
&gt;   int i;
&gt;   NoCC(const NoCC&amp;); // No definition
&gt; public:
&gt;   NoCC(int ii = 0) : i(ii) {}
&gt; };
&gt; 
&gt; void f(NoCC);
&gt; 
&gt; int main() {
&gt;   NoCC n;
&gt; //! f(n); // Error: copy-constructor called
&gt; //! NoCC n2 = n; // Error: c-c called
&gt; //! NoCC n3(n); // Error: c-c called
&gt; } ///:~
</code></pre>
<p>注意使用了更一般的形式</p>
<pre><code class="language-cpp">&gt; NoCC(const NoCC&amp;);
</code></pre>
<p>使用 <strong>const</strong>.</p>
<h4 id="functions-that-modify-outside-objects-修改外部对象的函数"><a class="header" href="#functions-that-modify-outside-objects-修改外部对象的函数">Functions that modify outside objects (修改外部对象的函数)</a></h4>
<p>引用语法比指针语法好用，但它会模糊读者的理解。例如，在 iostreams 库中，<strong>get( )</strong> 函数的一个重载版本将一个 <strong>char&amp;</strong> 作为参数，而该函数的全部意义在于通过插入 <strong>get( )</strong> 的结果来修改其参数。然而，当你阅读使用该函数的代码时，并不能立即看出外部对象被修改了：</p>
<pre><code class="language-cpp">&gt; char c;
&gt; cin.get(c); 
</code></pre>
<p>相反，函数调用看起来像逐值传递，这表明外部对象没有被修改。</p>
<p>因此，从代码维护的角度来看，在传递要修改的参数地址时使用指针可能更安全。如果你总是将地址作为 <strong>const</strong> 引用来传递，除非你打算通过地址来修改外部对象，这时你传递的是非<strong>const</strong>指针，那么你的代码就更容易被读者理解了。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="114-pointers-to-members成员指针"><a class="header" href="#114-pointers-to-members成员指针">11.4 Pointers to members(成员指针)</a></h2>
<p>指针是保存某个位置地址的变量。您可以在运行时更改指针选择的位置，指针的目的地可以是数据或函数。C++ 的_pointer-to-member_遵循了同样的概念，只不过它选择的是类中的一个位置。这里的难题在于，指针需要一个地址，但类内部没有 "地址"；选择类的成员意味着偏移到该类中。只有将偏移量与特定对象的起始地址相结合，才能产生实际地址。成员指针的语法要求在取消引用成员指针的同时选择一个对象。</p>
<p>要理解这种语法，请考虑一个简单的结构体，该结构体有一个指针 <strong>sp</strong> 和一个对象 <strong>so</strong>。您可以使用所示语法选择成员：</p>
<pre><code class="language-cpp">&gt; //: C11:SimpleStructure.cpp
&gt; struct Simple { int a; };
&gt; int main() {
&gt;   Simple so, *sp = &amp;so;
&gt;   sp-&gt;a;
&gt;   so.a;
&gt; } ///:~
</code></pre>
<p>现在，假设你有一个指向整数 <strong>ip</strong> 的普通指针。要访问<strong>ip</strong>指向的内容，需要使用 "<code>*</code>"对指针进行反引用：</p>
<pre><code class="language-cpp">&gt; *ip = 4;
</code></pre>
<p>最后，考虑一下如果有一个指针恰好指向一个类对象内部的某物，即使它实际上表示对象的偏移量，会发生什么情况。要访问指针指向的内容，必须使用 <strong><code>*</code></strong> 对其进行反引用。但它是一个对象的偏移量，因此还必须引用该特定对象。因此，<strong><code>*</code></strong> 与对象取消引用相结合。因此，新的语法变成 <strong><code>-&gt;</code></strong>* 表示指向对象的指针，<strong><code>.</code></strong>* 表示对象或引用，就像这样：</p>
<pre><code class="language-cpp">&gt; objectPointer-&gt;*pointerToMember = 47;
&gt; object.*pointerToMember = 47;
</code></pre>
<p>现在，定义 <strong>pointerToMember</strong> 的语法是什么？与任何指针一样，你必须说明它指向的类型，并在定义中使用 <strong><code>*</code></strong>。唯一不同的是，你必须说明这个指针转成员的对象类别。当然，这可以通过类名和作用域解析操作符来实现。因此</p>
<pre><code class="language-cpp">&gt; int ObjectClass::*pointerToMember;
</code></pre>
<p>定义了一个名为<strong>pointerToMember</strong>的指针到成员变量，该变量指向<strong>ObjectClass</strong>内部的任意<strong>int</strong>。您也可以在定义时（或其他任何时候）初始化指针到成员变量：</p>
<pre><code class="language-cpp">&gt; int ObjectClass::*pointerToMember = &amp;ObjectClass::a;
</code></pre>
<p>实际上，<strong>ObjectClass::a</strong> 并没有 "地址"，因为您只是在引用类，而不是该类的对象。因此，<strong>&amp;ObjectClass::a</strong> 只能用作指针到成员的语法。</p>
<p>下面的示例展示了如何创建和使用指向数据成员的指针：</p>
<pre><code class="language-cpp">&gt; //: C11:PointerToMemberData.cpp
&gt; #include &lt;iostream&gt;
&gt; using namespace std;
&gt; 
&gt; class Data {
&gt; public:  
&gt;   int a, b, c; 
&gt;   void print() const {
&gt;     cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; ", b = " &lt;&lt; b
&gt;          &lt;&lt; ", c = " &lt;&lt; c &lt;&lt; endl;
&gt;   }
&gt; };
&gt; 
&gt; int main() {
&gt;   Data d, *dp = &amp;d;
&gt;   int Data::*pmInt = &amp;Data::a;
&gt;   dp-&gt;*pmInt = 47;
&gt;   pmInt = &amp;Data::b;
&gt;   d.*pmInt = 48;
&gt;   pmInt = &amp;Data::c;
&gt;   dp-&gt;*pmInt = 49;
&gt;   dp-&gt;print();
&gt; } ///:~
</code></pre>
<p>显然，除了特殊情况（这也正是它们的初衷），在其他任何地方使用它们都过于笨拙。</p>
<p>此外，指向成员的指针也有相当大的局限性：它们只能被分配到类内部的特定位置。例如，你不能像使用普通指针那样对它们进行递增或比较。</p>
<h3 id="functions--函数"><a class="header" href="#functions--函数">Functions  (函数)</a></h3>
<p>类似的练习可以产生成员函数的指针到成员语法。函数指针（在第 3 章末尾介绍）是这样定义的：</p>
<pre><code class="language-cpp">&gt; int (*fp)(float);
</code></pre>
<p><strong>(<code>*fp</code>)</strong> 周围的括号是强制编译器正确评估定义所必需的。如果没有括号，这个函数看起来就像是一个返回  <strong>int</strong> *  的函数。</p>
<p>在定义和使用成员函数指针时，括号也起着重要作用。如果在一个类中有一个函数，则可以通过在普通函数指针定义中插入类名和作用域解析操作符来定义指向该成员函数的指针：</p>
<pre><code class="language-cpp">&gt; //: C11:PmemFunDefinition.cpp
&gt; class Simple2 { 
&gt; public: 
&gt;   int f(float) const { return 1; }
&gt; };
&gt; int (Simple2::*fp)(float) const;
&gt; int (Simple2::*fp2)(float) const = &amp;Simple2::f;
&gt; int main() {
&gt;   fp = &amp;Simple2::f;
&gt; } ///:~
</code></pre>
<p>在 <strong>fp2</strong> 的定义中，您可以看到成员函数的指针也可以在创建时或其他任何时候初始化。与非会员函数不同，在获取成员函数的地址时，<strong>&amp;</strong> 并非可选项。不过，您可以给出函数标识符，而无需参数列表，因为重载解析可以由成员函数指针的类型决定。</p>
<h4 id="an-example举例说明"><a class="header" href="#an-example举例说明">An example(举例说明)</a></h4>
<p>指针的价值在于你可以在运行时改变它指向的对象，这为你的编程提供了重要的灵活性，因为通过指针，你可以在运行时选择或改变_行为。成员指针也是如此，它允许你在运行时选择一个成员。通常情况下，您的类只会有公开可见的成员函数（数据成员通常被视为底层实现的一部分），因此下面的示例可以在运行时选择成员函数。</p>
<pre><code class="language-cpp">&gt; //: C11:PointerToMemberFunction.cpp
&gt; #include &lt;iostream&gt;
&gt; using namespace std;
&gt; 
&gt; class Widget {
&gt; public:
&gt;   void f(int) const { cout &lt;&lt; "Widget::f()\n"; }
&gt;   void g(int) const { cout &lt;&lt; "Widget::g()\n"; }
&gt;   void h(int) const { cout &lt;&lt; "Widget::h()\n"; }
&gt;   void i(int) const { cout &lt;&lt; "Widget::i()\n"; }
&gt; };
&gt; 
&gt; int main() {
&gt;   Widget w;
&gt;   Widget* wp = &amp;w;
&gt;   void (Widget::*pmem)(int) const = &amp;Widget::h;
&gt;   (w.*pmem)(1);
&gt;   (wp-&gt;*pmem)(2);
&gt; } ///:~
</code></pre>
<p>当然，期望普通用户创建如此复杂的表达式并不特别合理。如果用户必须直接操作指针转成员，那么就需要使用<strong>类型定义</strong>。要真正做到一尘不染，可以将指针到成员作为内部实现机制的一部分。下面是使用指针转成员_在类内部_的示例。用户只需输入一个数字即可选择一个函数。</p>
<pre><code class="language-cpp">&gt; //: C11:PointerToMemberFunction2.cpp
&gt; #include &lt;iostream&gt;
&gt; using namespace std;
&gt; 
&gt; class Widget {
&gt;   void f(int) const { cout &lt;&lt; "Widget::f()\n"; }
&gt;   void g(int) const { cout &lt;&lt; "Widget::g()\n"; }
&gt;   void h(int) const { cout &lt;&lt; "Widget::h()\n"; }
&gt;   void i(int) const { cout &lt;&lt; "Widget::i()\n"; }
&gt;   enum { cnt = 4 };
&gt;   void (Widget::*fptr[cnt])(int) const;
&gt; public:
&gt;   Widget() {
&gt;     fptr[0] = &amp;Widget::f; // Full spec required
&gt;     fptr[1] = &amp;Widget::g;
&gt;     fptr[2] = &amp;Widget::h;
&gt;     fptr[3] = &amp;Widget::i;
&gt;   }
&gt;   void select(int i, int j) {
&gt;     if(i &lt; 0 || i &gt;= cnt) return;
&gt;     (this-&gt;*fptr[i])(j);
&gt;   }
&gt;   int count() { return cnt; }
&gt; };
&gt; 
&gt; int main() {
&gt;   Widget w;
&gt;   for(int i = 0; i &lt; w.count(); i++)
&gt;     w.select(i, 47);
&gt; } ///:~
</code></pre>
<p>在类界面和 <strong>main( )</strong> 中，你可以看到包括函数在内的整个实现都被隐藏起来了。代码甚至必须询问函数的<strong>count( )</strong>。这样，类的实现者就可以改变底层实现中的函数数量，而不会影响使用该类的代码。</p>
<p>在构造函数中对成员指针的初始化似乎过于规范。难道不应该说</p>
<pre><code class="language-cpp">&gt; fptr[1] = &amp;g;
</code></pre>
<p>因为 <strong>g</strong> 这个名字出现在成员函数中，而成员函数自动处于类的作用域中？问题是这不符合成员指针语法，而成员指针语法是每个人（尤其是编译器）都必须掌握的。同样，当指针到成员被取消引用时，似乎是</p>
<pre><code class="language-cpp">&gt; (this-&gt;*fptr[i])(j);
</code></pre>
<p>也指定得过多；<strong>这</strong>看起来是多余的。同样，语法要求成员指针在被取消引用时始终与对象绑定。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>C++ 中的指针与 C 中的指针几乎完全相同，这是好事。否则，很多 C 代码都无法在 C++ 下正常编译。唯一会产生的编译时错误发生在危险赋值上。如果这些赋值确实是我们想要的，那么只需一个简单（显式！）的转置就能消除编译时错误。</p>
<p>C++ 还添加了 Algol 和 Pascal 中的 <em>reference</em>，它就像一个常量指针，会被编译器自动取消引用。引用持有一个地址，但你可以像对待对象一样对待它。引用对于使用操作符重载（下一章的主题）的简洁语法至关重要，同时也为普通函数传递和返回对象提供了语法上的便利。</p>
<p>复制构造函数的参数是一个同类型现有对象的引用，它用于从现有对象创建一个新对象。当您传递或返回一个对象时，编译器会自动调用复制构造函数。虽然编译器会自动为你创建一个复制构造函数，但如果你认为你的类需要一个复制构造函数，你应该自己定义它，以确保发生正确的行为。如果不希望通过值传递或返回对象，则应创建一个私有的复制构造函数。</p>
<p>指向成员的指针具有与普通指针相同的功能：您可以在运行时选择特定的存储区域（数据或函数）。指向成员的指针只是与类成员协同工作，而不是与全局数据或函数协同工作。您可以获得编程的灵活性，从而在运行时改变行为。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>

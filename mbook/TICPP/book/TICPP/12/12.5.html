<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>12.5重载赋值 - TICPP</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../TICPP/11/11.0.html"><strong aria-hidden="true">1.</strong> 11.References & the Copy-Constructor)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../TICPP/11/11.1.html"><strong aria-hidden="true">1.1.</strong> 11.1C++ 中的指针</a></li><li class="chapter-item expanded "><a href="../../TICPP/11/11.2.html"><strong aria-hidden="true">1.2.</strong> 11.2C++ 中的引用</a></li><li class="chapter-item expanded "><a href="../../TICPP/11/11.3.html"><strong aria-hidden="true">1.3.</strong> 11.3拷贝构造函数</a></li><li class="chapter-item expanded "><a href="../../TICPP/11/11.4.html"><strong aria-hidden="true">1.4.</strong> 11.成员指针</a></li><li class="chapter-item expanded "><a href="../../TICPP/11/11.5.html"><strong aria-hidden="true">1.5.</strong> 11.Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../../TICPP/12/12.0.html"><strong aria-hidden="true">2.</strong> 12.Operator Overloading)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../TICPP/12/12.1.html"><strong aria-hidden="true">2.1.</strong> 12.1警告与保证</a></li><li class="chapter-item expanded "><a href="../../TICPP/12/12.2.html"><strong aria-hidden="true">2.2.</strong> 12.2语法</a></li><li class="chapter-item expanded "><a href="../../TICPP/12/12.3.html"><strong aria-hidden="true">2.3.</strong> 12.3可重载操作符</a></li><li class="chapter-item expanded "><a href="../../TICPP/12/12.4.html"><strong aria-hidden="true">2.4.</strong> 12.4非成员操作符</a></li><li class="chapter-item expanded "><a href="../../TICPP/12/12.5.html" class="active"><strong aria-hidden="true">2.5.</strong> 12.5重载赋值</a></li><li class="chapter-item expanded "><a href="../../TICPP/12/12.6.html"><strong aria-hidden="true">2.6.</strong> 12.6自动类型转换</a></li><li class="chapter-item expanded "><a href="../../TICPP/12/12.7.html"><strong aria-hidden="true">2.7.</strong> 12.7构造器转换</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">TICPP</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="overloading-assignment-重载赋值"><a class="header" href="#overloading-assignment-重载赋值">Overloading assignment (重载赋值)</a></h2>
<p>赋值是初学 C++ 的程序员经常感到困惑的一个问题。毫无疑问，这是因为 <strong>=</strong> 符号是编程中的基本操作符，就连在机器级复制寄存器也是如此。此外，在使用 <strong>=</strong> 符号时，有时还会调用复制构造函数（第 11 章中有介绍）：</p>
<pre><code class="language-cpp">&gt; MyType b;
&gt; MyType a = b;
&gt; a = b;
</code></pre>
<p>在第二行中，对象 <strong>a</strong> 正在被定义。一个新对象正在被创建，而之前并不存在。因为你现在已经知道 C++ 编译器在对象初始化方面有多么严防死守，所以你知道在定义对象时必须调用一个构造函数。但哪个构造函数呢？<strong>a</strong>是从已有的<strong>MyType</strong>对象（<strong>b</strong>，在等号的右边）创建的，所以只有一个选择：复制构造函数。即使涉及等号，也会调用复制构造函数。</p>
<p>在第三行中，情况有所不同。在等号的左边，有一个已经初始化的对象。显然，我们不能为一个已经创建的对象调用构造函数。在这种情况下，<strong>MyType::operator=</strong> 会为 <strong>a</strong>调用，并将右侧出现的内容作为参数。(您可以使用多个 <strong>operator=</strong> 函数来获取不同类型的右侧参数）。</p>
<p>这种行为并不局限于复制构造函数。在使用 <strong>=</strong> 而非构造函数的普通函数调用形式初始化对象时，编译器都会寻找一个能接受右侧内容的构造函数：</p>
<pre><code class="language-cpp">&gt; //: C12:CopyingVsInitialization.cpp
&gt; class Fi {
&gt; public:
&gt;   Fi() {}
&gt; };
&gt; 
&gt; class Fee {
&gt; public:
&gt;   Fee(int) {}
&gt;   Fee(const Fi&amp;) {}
&gt; };
&gt; 
&gt; int main() {
&gt;   Fee fee = 1; // Fee(int)
&gt;   Fi fi;
&gt;   Fee fum = fi; // Fee(Fi)
&gt; } ///:~
</code></pre>
<p>在使用 <strong>=</strong> 符号时，必须牢记这一区别： 如果对象尚未创建，则需要进行初始化；否则将使用赋值<strong>operator=</strong>。</p>
<p>最好不要编写使用 <strong>=</strong> 进行初始化的代码，而应始终使用显式构造函数形式。这样，两个带等号的构造函数就变成了</p>
<pre><code class="language-cpp">&gt; Fee fee(1);
&gt; Fee fum(fi);
</code></pre>
<p>这样，您就可以避免读者感到困惑。</p>
<h3 id="behavior-of-operator--操作符-的行为--"><a class="header" href="#behavior-of-operator--操作符-的行为--">Behavior of operator=  (操作符= 的行为  )</a></h3>
<p>在 <strong>Integer.h</strong> 和 <strong>Byte.h</strong> 中，您看到 <strong>operator=</strong> 只能是一个成员函数。它与'<strong>=</strong>'左边的对象密切相关。如果可以全局定义<strong>operator=</strong>，那么您可能会尝试重新定义内置的'<strong>=</strong>'符号：</p>
<pre><code class="language-cpp">&gt; int operator=(int, MyType); // Global = not allowed!
</code></pre>
<p>编译器会强迫你将 <strong>operator=</strong> 作为成员函数，从而回避整个问题。</p>
<p>创建 <strong>operator=</strong> 时，必须将右侧对象中的所有必要信息复制到当前对象（即 <strong>operator=</strong> 被调用的对象）中，以便为类执行任何你认为的 "赋值 "操作符。对于简单对象，这一点显而易见：</p>
<pre><code class="language-cpp">&gt; //: C12:SimpleAssignment.cpp
&gt; // Simple operator=()
&gt; #include &lt;iostream&gt;
&gt; 
&gt; using namespace std;
&gt; 
&gt; class Value {
&gt;   int a, b;
&gt;   float c;
&gt; public:
&gt;   Value(int aa = 0, int bb = 0, float cc = 0.0)
&gt;     : a(aa), b(bb), c(cc) {}
&gt;   Value&amp; operator=(const Value&amp; rv) {
&gt;     a = rv.a;
&gt;     b = rv.b;
&gt;     c = rv.c;
&gt;     return *this;
&gt;   }
&gt;   friend ostream&amp;
&gt;   operator&lt;&lt;(ostream&amp; os, const Value&amp; rv) {
&gt;     return os &lt;&lt; "a = " &lt;&lt; rv.a &lt;&lt; ", b = "
&gt;       &lt;&lt; rv.b &lt;&lt; ", c = " &lt;&lt; rv.c;
&gt;   }
&gt; };
&gt; 
&gt; int main() {
&gt;   Value a, b(1, 2, 3.3);
&gt;   cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; endl;
&gt;   cout &lt;&lt; "b: " &lt;&lt; b &lt;&lt; endl;
&gt;   a = b;
&gt;   cout &lt;&lt; "a after assignment: " &lt;&lt; a &lt;&lt; endl;
&gt; } ///:~
&gt; 
</code></pre>
<p>在这里，<strong>=</strong> 左边的对象复制了右边对象的所有元素，然后返回对自身的引用，这样就可以创建一个更复杂的表达式。</p>
<p>这个示例包含一个常见错误。在给两个相同类型的对象赋值时，应首先检查是否存在自赋值：对象是否被赋值给了自己？在某些情况下，比如本例，无论如何进行赋值操作都是无害的，但如果对类的实现进行了修改，就会产生不同的效果，如果不按习惯进行，就可能会忘记，从而导致难以发现的错误。</p>
<h4 id="pointers-in-classes--类中的指针"><a class="header" href="#pointers-in-classes--类中的指针">Pointers in classes  (类中的指针)</a></h4>
<p>如果对象不那么简单会怎样？例如，如果对象包含指向其他对象的指针怎么办？简单地复制指针意味着最终会有两个对象指向同一个存储位置。在这种情况下，你需要自己进行记账。</p>
<p>解决这个问题有两种常见的方法。最简单的方法是在进行赋值或复制构造时，复制指针所指的任何内容。这种方法简单明了：</p>
<pre><code class="language-cpp">&gt; //: C12:CopyingWithPointers.cpp
&gt; // Solving the pointer aliasing problem by
&gt; // duplicating what is pointed to during 
&gt; // assignment and copy-construction.
&gt; #include "../require.h"
&gt; #include &lt;string&gt;
&gt; #include &lt;iostream&gt;
&gt; using namespace std;
&gt; 
&gt; class Dog {
&gt;   string nm;
&gt; public:
&gt;   Dog(const string&amp; name) : nm(name) {
&gt;     cout &lt;&lt; "Creating Dog: " &lt;&lt; *this &lt;&lt; endl;
&gt;   }
&gt;   // Synthesized copy-constructor &amp; operator= 
&gt;   // are correct.
&gt;   // Create a Dog from a Dog pointer:
&gt;   Dog(const Dog* dp, const string&amp; msg) 
&gt;     : nm(dp-&gt;nm + msg) {
&gt;     cout &lt;&lt; "Copied dog " &lt;&lt; *this &lt;&lt; " from "
&gt;          &lt;&lt; *dp &lt;&lt; endl;
&gt;   }
&gt;   ~Dog() { 
&gt;     cout &lt;&lt; "Deleting Dog: " &lt;&lt; *this &lt;&lt; endl;
&gt;   }
&gt;   void rename(const string&amp; newName) {
&gt;     nm = newName;
&gt;     cout &lt;&lt; "Dog renamed to: " &lt;&lt; *this &lt;&lt; endl;
&gt;   }
&gt;   friend ostream&amp;
&gt;   operator&lt;&lt;(ostream&amp; os, const Dog&amp; d) {
&gt;     return os &lt;&lt; "[" &lt;&lt; d.nm &lt;&lt; "]";
&gt;   }
&gt; };
&gt; 
&gt; class DogHouse {
&gt;   Dog* p;
&gt;   string houseName;
&gt; public:
&gt;   DogHouse(Dog* dog, const string&amp; house)
&gt;    : p(dog), houseName(house) {}
&gt;   DogHouse(const DogHouse&amp; dh)
&gt;     : p(new Dog(dh.p, " copy-constructed")),
&gt;       houseName(dh.houseName 
&gt;         + " copy-constructed") {}
&gt;   DogHouse&amp; operator=(const DogHouse&amp; dh) {
&gt;     // Check for self-assignment:
&gt;     if(&amp;dh != this) {
&gt;       p = new Dog(dh.p, " assigned");
&gt;       houseName = dh.houseName + " assigned";
&gt;     }
&gt;     return *this;
&gt;   }
&gt;   void renameHouse(const string&amp; newName) {
&gt;     houseName = newName;
&gt;   }
&gt;   Dog* getDog() const { return p; }
&gt;   ~DogHouse() { delete p; }
&gt;   friend ostream&amp;
&gt;   operator&lt;&lt;(ostream&amp; os, const DogHouse&amp; dh) {
&gt;     return os &lt;&lt; "[" &lt;&lt; dh.houseName 
&gt;       &lt;&lt; "] contains " &lt;&lt; *dh.p;
&gt;   }
&gt; }; 
&gt; 
&gt; int main() {
&gt;   DogHouse fidos(new Dog("Fido"), "FidoHouse");
&gt;   cout &lt;&lt; fidos &lt;&lt; endl;
&gt;   DogHouse fidos2 = fidos; // Copy construction
&gt;   cout &lt;&lt; fidos2 &lt;&lt; endl;
&gt;   fidos2.getDog()-&gt;rename("Spot");
&gt;   fidos2.renameHouse("SpotHouse");
&gt;   cout &lt;&lt; fidos2 &lt;&lt; endl;
&gt;   fidos = fidos2; // Assignment
&gt;   cout &lt;&lt; fidos &lt;&lt; endl;
&gt;   fidos.getDog()-&gt;rename("Max");
&gt;   fidos2.renameHouse("MaxHouse");
&gt; } ///:~
</code></pre>
<p><strong>狗</strong>是一个简单的类，只包含一个<strong>字符串</strong>，用来保存狗的名字。不过，当 <strong>Dog</strong> 发生变化时，你一般都能知道，因为构造函数和析构函数在调用时都会打印信息。请注意，第二个构造函数有点像拷贝构造函数，只不过它使用的是指向<strong>狗</strong>的指针而不是引用，而且它的第二个参数是一条与参数<strong>狗</strong>的名称相串联的信息。这有助于追踪程序的行为。</p>
<p>你可以看到，每当成员函数打印信息时，它并不直接访问该信息，而是将 <em><strong>this</strong> 发送给 <strong>cout</strong> 。这反过来又调用了</em><em>ostream</em>* <strong>操作符&lt;&lt;</strong>。这样做很有价值，因为如果你想重新格式化<strong>Dog</strong>信息的显示方式（就像我添加'['和']'一样），你只需要在一个地方进行操作即可。</p>
<p>一个<strong>DogHouse</strong>包含一只<strong>Dog</strong>*，并演示了当类中包含指针时需要定义的四个函数：所有必要的普通构造函数、复制构造函数、<strong>operator=</strong>（定义或禁止）和一个析构函数。<strong>operator=</strong> 当然要检查自赋值，尽管它在这里并非严格必要。这几乎消除了在修改代码时忘记检查自赋值的可能性。</p>
<h4 id="reference-counting-引用计数"><a class="header" href="#reference-counting-引用计数">Reference Counting (引用计数)</a></h4>
<p>在上面的示例中，复制构造函数和 <strong>operator=</strong> 为指针指向的对象制作了一个新副本，而析构函数则删除了它。但是，如果你的对象需要大量内存或较高的初始化开销，你可能希望避免这种复制。解决这一问题的常用方法是_引用计数_。你可以为被指向的对象提供智能，让它知道有多少个对象在指向它。然后，复制-构造或赋值意味着将另一个指针附加到现有对象上，并增加引用计数。销毁指的是减少引用计数，并在引用计数为零时销毁对象。</p>
<p>但如果你想写入对象（上例中的<strong>狗</strong>）呢？可能有不止一个对象在使用这个<strong>狗</strong>，所以你在修改自己的<strong>狗</strong>的同时，也在修改别人的<strong>狗</strong>，这似乎不太友好。为了解决这个 "别名 "问题，我们使用了一种名为 "写入时复制"（<em>copy-on-write</em>）的附加技术。在写入内存块之前，要确保没有其他人正在使用该内存块。如果引用计数大于 1，那么在写入该内存块之前，必须为自己复制一份该内存块的个人副本，这样就不会打扰别人的地盘了。下面是一个引用计数和写时拷贝的简单示例：</p>
<pre><code class="language-cpp">&gt; //: C12:ReferenceCounting.cpp
&gt; // Reference count, copy-on-write
&gt; #include "../require.h"
&gt; #include &lt;string&gt;
&gt; #include &lt;iostream&gt;
&gt; using namespace std;
&gt; 
&gt; class Dog {
&gt;   string nm;
&gt;   int refcount;
&gt;   Dog(const string&amp; name) 
&gt;     : nm(name), refcount(1) {
&gt;     cout &lt;&lt; "Creating Dog: " &lt;&lt; *this &lt;&lt; endl;
&gt;   }
&gt;   // Prevent assignment:
&gt;   Dog&amp; operator=(const Dog&amp; rv);
&gt; public:
&gt;   // Dogs can only be created on the heap:
&gt;   static Dog* make(const string&amp; name) {
&gt;     return new Dog(name);
&gt;   }
&gt;   Dog(const Dog&amp; d) 
&gt;     : nm(d.nm + " copy"), refcount(1) {
&gt;     cout &lt;&lt; "Dog copy-constructor: " 
&gt;          &lt;&lt; *this &lt;&lt; endl;
&gt;   }
&gt;   ~Dog() { 
&gt;     cout &lt;&lt; "Deleting Dog: " &lt;&lt; *this &lt;&lt; endl;
&gt;   }
&gt;   void attach() { 
&gt;     ++refcount;
&gt;     cout &lt;&lt; "Attached Dog: " &lt;&lt; *this &lt;&lt; endl;
&gt;   }
&gt;   void detach() {
&gt;     require(refcount != 0);
&gt;     cout &lt;&lt; "Detaching Dog: " &lt;&lt; *this &lt;&lt; endl;
&gt;     // Destroy object if no one is using it:
&gt;     if(--refcount == 0) delete this;
&gt;   }
&gt;   // Conditionally copy this Dog.
&gt;   // Call before modifying the Dog, assign
&gt;   // resulting pointer to your Dog*.
&gt;   Dog* unalias() {
&gt;     cout &lt;&lt; "Unaliasing Dog: " &lt;&lt; *this &lt;&lt; endl;
&gt;     // Don't duplicate if not aliased:
&gt;     if(refcount == 1) return this;
&gt;     --refcount;
&gt;     // Use copy-constructor to duplicate:
&gt;     return new Dog(*this);
&gt;   }
&gt;   void rename(const string&amp; newName) {
&gt;     nm = newName;
&gt;     cout &lt;&lt; "Dog renamed to: " &lt;&lt; *this &lt;&lt; endl;
&gt;   }
&gt;   friend ostream&amp;
&gt;   operator&lt;&lt;(ostream&amp; os, const Dog&amp; d) {
&gt;     return os &lt;&lt; "[" &lt;&lt; d.nm &lt;&lt; "], rc = " 
&gt;       &lt;&lt; d.refcount;
&gt;   }
&gt; };
&gt; 
&gt; class DogHouse {
&gt;   Dog* p;
&gt;   string houseName;
&gt; public:
&gt;   DogHouse(Dog* dog, const string&amp; house)
&gt;    : p(dog), houseName(house) {
&gt;     cout &lt;&lt; "Created DogHouse: "&lt;&lt; *this &lt;&lt; endl;
&gt;   }
&gt;   DogHouse(const DogHouse&amp; dh)
&gt;     : p(dh.p),
&gt;       houseName("copy-constructed " + 
&gt;         dh.houseName) {
&gt;     p-&gt;attach();
&gt;     cout &lt;&lt; "DogHouse copy-constructor: "
&gt;          &lt;&lt; *this &lt;&lt; endl;
&gt;   }
&gt;   DogHouse&amp; operator=(const DogHouse&amp; dh) {
&gt;     // Check for self-assignment:
&gt;     if(&amp;dh != this) {
&gt;       houseName = dh.houseName + " assigned";
&gt;       // Clean up what you're using first:
&gt;       p-&gt;detach();
&gt;       p = dh.p; // Like copy-constructor
&gt;       p-&gt;attach();
&gt;     }
&gt;     cout &lt;&lt; "DogHouse operator= : "
&gt;          &lt;&lt; *this &lt;&lt; endl;
&gt;     return *this;
&gt;   }
&gt;   // Decrement refcount, conditionally destroy
&gt;   ~DogHouse() {
&gt;     cout &lt;&lt; "DogHouse destructor: " 
&gt;          &lt;&lt; *this &lt;&lt; endl;
&gt;     p-&gt;detach(); 
&gt;   }
&gt;   void renameHouse(const string&amp; newName) {
&gt;     houseName = newName;
&gt;   }
&gt;   void unalias() { p = p-&gt;unalias(); }
&gt;   // Copy-on-write. Anytime you modify the 
&gt;   // contents of the pointer you must 
&gt;   // first unalias it:
&gt;   void renameDog(const string&amp; newName) {
&gt;     unalias();
&gt;     p-&gt;rename(newName);
&gt;   }
&gt;   // ... or when you allow someone else access:
&gt;   Dog* getDog() {
&gt;     unalias();
&gt;     return p; 
&gt;   }
&gt;   friend ostream&amp;
&gt;   operator&lt;&lt;(ostream&amp; os, const DogHouse&amp; dh) {
&gt;     return os &lt;&lt; "[" &lt;&lt; dh.houseName 
&gt;       &lt;&lt; "] contains " &lt;&lt; *dh.p;
&gt;   }
&gt; }; 
&gt; 
&gt; int main() {
&gt;   DogHouse 
&gt;     fidos(Dog::make("Fido"), "FidoHouse"),
&gt;     spots(Dog::make("Spot"), "SpotHouse");
&gt;   cout &lt;&lt; "Entering copy-construction" &lt;&lt; endl;
&gt;   DogHouse bobs(fidos);
&gt;   cout &lt;&lt; "After copy-constructing bobs" &lt;&lt; endl;
&gt;   cout &lt;&lt; "fidos:" &lt;&lt; fidos &lt;&lt; endl;
&gt;   cout &lt;&lt; "spots:" &lt;&lt; spots &lt;&lt; endl;
&gt;   cout &lt;&lt; "bobs:" &lt;&lt; bobs &lt;&lt; endl;
&gt;   cout &lt;&lt; "Entering spots = fidos" &lt;&lt; endl;
&gt;   spots = fidos;
&gt;   cout &lt;&lt; "After spots = fidos" &lt;&lt; endl;
&gt;   cout &lt;&lt; "spots:" &lt;&lt; spots &lt;&lt; endl;
&gt;   cout &lt;&lt; "Entering self-assignment" &lt;&lt; endl;
&gt;   bobs = bobs;
&gt;   cout &lt;&lt; "After self-assignment" &lt;&lt; endl;
&gt;   cout &lt;&lt; "bobs:" &lt;&lt; bobs &lt;&lt; endl;
&gt;   // Comment out the following lines:
&gt;   cout &lt;&lt; "Entering rename(\"Bob\")" &lt;&lt; endl;
&gt;   bobs.getDog()-&gt;rename("Bob");
&gt;   cout &lt;&lt; "After rename(\"Bob\")" &lt;&lt; endl;
&gt; } ///:~
</code></pre>
<p>类 <strong>Dog</strong> 是 <strong>DogHouse</strong> 指向的对象。它包含一个引用计数以及控制和读取引用计数的函数。还有一个复制构造函数，这样你就可以从一个已有的<strong>Dog</strong>中创建一个新的<strong>Dog</strong>。</p>
<p><strong>attach( )</strong> 函数会增加<strong>Dog</strong>的引用计数，以表示有另一个对象在使用它。<strong>detach( )</strong> 会减少引用计数。如果引用计数为零，则表示没有人再使用它，因此成员函数会通过<strong>delete this</strong>来销毁自己的对象。</p>
<p>在进行任何修改（如重命名<strong>狗</strong>）之前，应确保不会更改其他对象正在使用的<strong>狗</strong>。为此，你可以调用 <strong>DogHouse::unalias( )</strong>，然后再调用 <strong>Dog::unalias( )</strong>。如果引用数为 1（即没有其他对象指向该<strong>Dog</strong>），后一个函数将返回现有的<strong>Dog</strong>指针，但如果引用数超过 1，则会复制该<strong>Dog</strong>。</p>
<p>复制构造函数没有创建自己的内存，而是将<strong>Dog</strong>赋值给源对象的<strong>Dog</strong>。然后，由于现在有一个额外的对象在使用该内存块，它会通过调用 <strong>Dog::attach( )</strong> 来增加引用计数。</p>
<p><strong>operator=</strong> 操作符处理的对象已在 <strong>=</strong> 左侧创建，因此它必须首先通过调用 <strong>detach( )</strong> 来清理该 <strong>Dog</strong> ，如果没有其他人使用该 <strong>Dog</strong> ，它将销毁旧的 <strong>Dog</strong> 。然后，<strong>operator=</strong> 重复拷贝构造函数的行为。请注意，它首先会检查是否将同一个对象赋值给自己。</p>
<p>析构函数调用 <strong>detach( )</strong> 来有条件地销毁 <strong>Dog</strong> 。</p>
<p>要实现写入时复制，必须控制所有写入内存块的操作。例如，<strong>renameDog( )</strong> 成员函数允许你更改内存块中的值。但首先，它要使用 <strong>unalias( )</strong> 来防止修改别名<strong>Dog</strong>（指向一个以上 <strong>DogHouse</strong> 对象的<strong>Dog</strong>）。如果需要从一个<strong>DogHouse</strong>中生成指向一个<strong>Dog</strong>的指针，则首先要<strong>unalias( )</strong> 该指针。</p>
<p><strong>main( )</strong> 测试实现引用计数所必须正确工作的各种函数：构造函数、复制构造函数、**操作符=**和析构函数。它还通过调用 <strong>renameDog( )</strong> 测试写入时复制。</p>
<p>以下是输出结果（稍作格式化后）：</p>
<pre><code class="language-cpp">&gt; Creating Dog: [Fido], rc = 1
&gt; Created DogHouse: [FidoHouse] 
&gt;   contains [Fido], rc = 1
&gt; Creating Dog: [Spot], rc = 1
&gt; Created DogHouse: [SpotHouse] 
&gt;   contains [Spot], rc = 1
&gt; Entering copy-construction
&gt; Attached Dog: [Fido], rc = 2
&gt; DogHouse copy-constructor: 
&gt;   [copy-constructed FidoHouse] 
&gt;     contains [Fido], rc = 2
&gt; After copy-constructing bobs
&gt; fidos:[FidoHouse] contains [Fido], rc = 2
&gt; spots:[SpotHouse] contains [Spot], rc = 1
&gt; bobs:[copy-constructed FidoHouse] 
&gt;   contains [Fido], rc = 2
&gt; Entering spots = fidos
&gt; Detaching Dog: [Spot], rc = 1
&gt; Deleting Dog: [Spot], rc = 0
&gt; Attached Dog: [Fido], rc = 3
&gt; DogHouse operator= : [FidoHouse assigned]
&gt;   contains [Fido], rc = 3
&gt; After spots = fidos
&gt; spots:[FidoHouse assigned] contains [Fido],rc = 3
&gt; Entering self-assignment
&gt; DogHouse operator= : [copy-constructed FidoHouse]
&gt;   contains [Fido], rc = 3
&gt; After self-assignment
&gt; bobs:[copy-constructed FidoHouse] 
&gt;   contains [Fido], rc = 3
&gt; Entering rename("Bob")
&gt; After rename("Bob")
&gt; DogHouse destructor: [copy-constructed FidoHouse]
&gt;   contains [Fido], rc = 3
&gt; Detaching Dog: [Fido], rc = 3
&gt; DogHouse destructor: [FidoHouse assigned] 
&gt;   contains [Fido], rc = 2
&gt; Detaching Dog: [Fido], rc = 2
&gt; DogHouse destructor: [FidoHouse] 
&gt;   contains [Fido], rc = 1
&gt; Detaching Dog: [Fido], rc = 1
&gt; Deleting Dog: [Fido], rc = 0
</code></pre>
<p>通过研究输出结果、追踪源代码和实验程序，你将加深对这些技术的理解。</p>
<h4 id="automatic-operator-creation--自动操作符-创建--"><a class="header" href="#automatic-operator-creation--自动操作符-创建--">Automatic operator= creation  (自动操作符= 创建  )</a></h4>
<p>因为将一个对象赋值给另一个_同类型_的对象是大多数人都希望可以实现的活动，所以如果你没有创建<strong>type::operator=(type)</strong>，编译器会自动创建一个<strong>type::operator=(type)</strong>。该操作符的行为与自动创建的复制构造函数类似；如果类中包含对象（或继承自其他类），则会递归调用这些对象的<strong>operator=</strong>。这就是所谓的_memberwise assignment_（成员赋值）。例如</p>
<pre><code class="language-cpp">&gt; //: C12:AutomaticOperatorEquals.cpp
&gt; #include &lt;iostream&gt;
&gt; using namespace std;
&gt; 
&gt; class Cargo {
&gt; public:
&gt;   Cargo&amp; operator=(const Cargo&amp;) {
&gt;     cout &lt;&lt; "inside Cargo::operator=()" &lt;&lt; endl;
&gt;     return *this;
&gt;   }
&gt; };
&gt; 
&gt; class Truck {
&gt;   Cargo b;
&gt; };
&gt; 
&gt; int main() {
&gt;   Truck a, b;
&gt;   a = b; // Prints: "inside Cargo::operator=()"
&gt; } ///:~
</code></pre>
<p>为 <strong>Truck</strong> 自动生成的 <strong>operator=</strong> 调用 <strong>Cargo::operator=</strong> 。</p>
<p>一般来说，您不希望让编译器代劳。对于任何复杂的类（尤其是包含指针的类！），你都希望明确地创建一个 <strong>operator=</strong> 。如果实在不想让别人执行赋值，可以将 <strong>operator=</strong> 声明为 <strong>private</strong> 函数。(除非在类内部使用，否则不需要定义它）。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../TICPP/12/12.4.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../TICPP/12/12.6.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../TICPP/12/12.4.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../TICPP/12/12.6.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>12.3可重载操作符 - TICPP</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../TICPP/11/11.0.html"><strong aria-hidden="true">1.</strong> 11.References & the Copy-Constructor)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../TICPP/11/11.1.html"><strong aria-hidden="true">1.1.</strong> 11.1C++ 中的指针</a></li><li class="chapter-item expanded "><a href="../../TICPP/11/11.2.html"><strong aria-hidden="true">1.2.</strong> 11.2C++ 中的引用</a></li><li class="chapter-item expanded "><a href="../../TICPP/11/11.3.html"><strong aria-hidden="true">1.3.</strong> 11.3拷贝构造函数</a></li><li class="chapter-item expanded "><a href="../../TICPP/11/11.4.html"><strong aria-hidden="true">1.4.</strong> 11.成员指针</a></li><li class="chapter-item expanded "><a href="../../TICPP/11/11.5.html"><strong aria-hidden="true">1.5.</strong> 11.Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../../TICPP/12/12.0.html"><strong aria-hidden="true">2.</strong> 12.Operator Overloading)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../TICPP/12/12.1.html"><strong aria-hidden="true">2.1.</strong> 12.1警告与保证</a></li><li class="chapter-item expanded "><a href="../../TICPP/12/12.2.html"><strong aria-hidden="true">2.2.</strong> 12.2语法</a></li><li class="chapter-item expanded "><a href="../../TICPP/12/12.3.html" class="active"><strong aria-hidden="true">2.3.</strong> 12.3可重载操作符</a></li><li class="chapter-item expanded "><a href="../../TICPP/12/12.4.html"><strong aria-hidden="true">2.4.</strong> 12.4非成员操作符</a></li><li class="chapter-item expanded "><a href="../../TICPP/12/12.5.html"><strong aria-hidden="true">2.5.</strong> 12.5重载赋值</a></li><li class="chapter-item expanded "><a href="../../TICPP/12/12.6.html"><strong aria-hidden="true">2.6.</strong> 12.6自动类型转换</a></li><li class="chapter-item expanded "><a href="../../TICPP/12/12.7.html"><strong aria-hidden="true">2.7.</strong> 12.7构造器转换</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">TICPP</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="overloadable-operators-可重载操作符"><a class="header" href="#overloadable-operators-可重载操作符">Overloadable operators (可重载操作符)</a></h2>
<p>虽然您可以重载 C 语言中几乎所有可用的运算符，但运算符重载的使用受到相当大的限制。特别是，您不能组合目前在 C 语言中没有意义的运算符（例如用 ****** 表示幂级数），不能更改运算符的求值优先级，也不能更改运算符所需的参数数。这样做是有道理的--所有这些操作都会产生混淆而非澄清意义的运算符。</p>
<p>接下来的两个小节将举例说明所有 "常规 "运算符，并以您最可能使用的形式进行重载。</p>
<h3 id="unary-operators-一元运算符"><a class="header" href="#unary-operators-一元运算符">Unary operators (一元运算符)</a></h3>
<p>下面的示例展示了以全局函数（非成员 <strong>friend</strong> 函数）和成员函数的形式重载所有一元运算符的语法。这将扩展之前显示的 <strong>Integer</strong> 类，并添加一个新的 <strong>byte</strong> 类。特定运算符的含义取决于您使用它们的方式，但在做意想不到的事情之前，请考虑一下客户程序员。<br />
Here is a catalog of all the unary functions:</p>
<pre><code class="language-cpp">&gt; //: C12:OverloadingUnaryOperators.cpp
&gt; #include &lt;iostream&gt;
&gt; using namespace std;
&gt; 
&gt; // Non-member functions:
&gt; class Integer {
&gt;   long i;
&gt;   Integer* This() { return this; }
&gt; public:
&gt;   Integer(long ll = 0) : i(ll) {}
&gt;   // No side effects takes const&amp; argument:
&gt;   friend const Integer&amp;
&gt;     operator+(const Integer&amp; a);
&gt;   friend const Integer
&gt;     operator-(const Integer&amp; a);
&gt;   friend const Integer
&gt;     operator~(const Integer&amp; a);
&gt;   friend Integer*
&gt;     operator&amp;(Integer&amp; a);
&gt;   friend int
&gt;     operator!(const Integer&amp; a);
&gt;   // Side effects have non-const&amp; argument:
&gt;   // Prefix:
&gt;   friend const Integer&amp;
&gt;     operator++(Integer&amp; a);
&gt;   // Postfix:
&gt;   friend const Integer
&gt;     operator++(Integer&amp; a, int);
&gt;   // Prefix:
&gt;   friend const Integer&amp;
&gt;     operator--(Integer&amp; a);
&gt;   // Postfix:
&gt;   friend const Integer
&gt;     operator--(Integer&amp; a, int);
&gt; };
&gt; 
&gt; // Global operators:
&gt; const Integer&amp; operator+(const Integer&amp; a) {
&gt;   cout &lt;&lt; "+Integer\n";
&gt;   return a; // Unary + has no effect
&gt; }
&gt; const Integer operator-(const Integer&amp; a) {
&gt;   cout &lt;&lt; "-Integer\n";
&gt;   return Integer(-a.i);
&gt; }
&gt; const Integer operator~(const Integer&amp; a) {
&gt;   cout &lt;&lt; "~Integer\n";
&gt;   return Integer(~a.i);
&gt; }
&gt; Integer* operator&amp;(Integer&amp; a) {
&gt;   cout &lt;&lt; "&amp;Integer\n";
&gt;   return a.This(); // &amp;a is recursive!
&gt; }
&gt; int operator!(const Integer&amp; a) {
&gt;   cout &lt;&lt; "!Integer\n";
&gt;   return !a.i;
&gt; }
&gt; // Prefix; return incremented value
&gt; const Integer&amp; operator++(Integer&amp; a) {
&gt;   cout &lt;&lt; "++Integer\n";
&gt;   a.i++;
&gt;   return a;
&gt; }
&gt; // Postfix; return the value before increment:
&gt; const Integer operator++(Integer&amp; a, int) {
&gt;   cout &lt;&lt; "Integer++\n";
&gt;   Integer before(a.i);
&gt;   a.i++;
&gt;   return before;
&gt; }
&gt; // Prefix; return decremented value
&gt; const Integer&amp; operator--(Integer&amp; a) {
&gt;   cout &lt;&lt; "--Integer\n";
&gt;   a.i--;
&gt;   return a;
&gt; }
&gt; // Postfix; return the value before decrement:
&gt; const Integer operator--(Integer&amp; a, int) {
&gt;   cout &lt;&lt; "Integer--\n";
&gt;   Integer before(a.i);
&gt;   a.i--;
&gt;   return before;
&gt; }
&gt; 
&gt; // Show that the overloaded operators work:
&gt; void f(Integer a) {
&gt;   +a;
&gt;   -a;
&gt;   ~a;
&gt;   Integer* ip = &amp;a;
&gt;   !a;
&gt;   ++a;
&gt;   a++;
&gt;   --a;
&gt;   a--;
&gt; }
&gt; 
&gt; // Member functions (implicit "this"):
&gt; class Byte {
&gt;   unsigned char b;
&gt; public:
&gt;   Byte(unsigned char bb = 0) : b(bb) {}
&gt;   // No side effects: const member function:
&gt;   const Byte&amp; operator+() const {
&gt;     cout &lt;&lt; "+Byte\n";
&gt;     return *this;
&gt;   }
&gt;   const Byte operator-() const {
&gt;     cout &lt;&lt; "-Byte\n";
&gt;     return Byte(-b);
&gt;   }
&gt;   const Byte operator~() const {
&gt;     cout &lt;&lt; "~Byte\n";
&gt;     return Byte(~b);
&gt;   }
&gt;   Byte operator!() const {
&gt;     cout &lt;&lt; "!Byte\n";
&gt;     return Byte(!b);
&gt;   }
&gt;   Byte* operator&amp;() {
&gt;     cout &lt;&lt; "&amp;Byte\n";
&gt;     return this;
&gt;   }
&gt;   // Side effects: non-const member function:
&gt;   const Byte&amp; operator++() { // Prefix
&gt;     cout &lt;&lt; "++Byte\n";
&gt;     b++;
&gt;     return *this;
&gt;   }
&gt;   const Byte operator++(int) { // Postfix
&gt;     cout &lt;&lt; "Byte++\n";
&gt;     Byte before(b);
&gt;     b++;
&gt;     return before;
&gt;   }
&gt;   const Byte&amp; operator--() { // Prefix
&gt;     cout &lt;&lt; "--Byte\n";
&gt;     --b;
&gt;     return *this;
&gt;   }
&gt;   const Byte operator--(int) { // Postfix
&gt;     cout &lt;&lt; "Byte--\n";
&gt;     Byte before(b);
&gt;     --b;
&gt;     return before;
&gt;   }
&gt; };
&gt; 
&gt; void g(Byte b) {
&gt;   +b;
&gt;   -b;
&gt;   ~b;
&gt;   Byte* bp = &amp;b;
&gt;   !b;
&gt;   ++b;
&gt;   b++;
&gt;   --b;
&gt;   b--;
&gt; }
&gt; 
&gt; int main() {
&gt;   Integer a;
&gt;   f(a);
&gt;   Byte b;
&gt;   g(b);
&gt; } ///:~
</code></pre>
<p>函数根据传递参数的方式分组。稍后将给出如何传递和返回参数的指南。上面的形式（以及下一节中的形式）通常都是你会用到的，因此在重载你自己的运算符时，可以将它们作为一种模式。</p>
<h4 id="increment--decrement--递增和递减"><a class="header" href="#increment--decrement--递增和递减">Increment &amp; decrement  (递增和递减)</a></h4>
<p>重载的 <strong>++</strong> 和 <strong>- -</strong> 操作符带来了一个两难的问题，因为你希望能够调用不同的函数，这取决于它们是出现在所作用对象的前缀（prefix）还是后缀（postfix）。解决方法很简单，但有时人们一开始会觉得有点困惑。例如，当编译器看到 <strong>++a</strong> （一个前增加）时，它会生成对<strong>operator++(a)</strong> 的调用；但当它看到 <strong>a++</strong> 时， 会生成对 <strong>operator++(a, int)</strong> 的调用。也就是说，编译器通过调用不同的重载函数来区分这两种形式。在<strong>OverloadingUnaryOperators.cpp</strong>的成员函数版本中，如果编译器看到 <strong>++b</strong>，就会生成对<strong>B::operator++( )</strong> 的调用；如果看到<strong>b++</strong>，就会调用<strong>B::operator++(int)</strong>。</p>
<p>用户看到的只是前缀和后缀版本调用了不同的函数。然而，这两个函数调用具有不同的签名，因此它们链接到两个不同的函数体。编译器为 <strong>int</strong> 参数传递了一个虚拟常量值（由于该值从未使用过，因此从未赋予其标识符），从而为后缀版本生成了不同的签名。</p>
<h3 id="binary-operators--位运算"><a class="header" href="#binary-operators--位运算">Binary operators  (位运算)</a></h3>
<p>下面的列表重复了 <strong>OverloadingUnaryOperators.cpp</strong>中二进制运算符的示例，这样您就有了一个可以重载所有运算符的示例。同样，这里显示了全局版本和成员函数版本。</p>
<pre><code class="language-cpp">&gt; //: C12:Integer.h
&gt; // Non-member overloaded operators
&gt; #ifndef INTEGER_H
&gt; #define INTEGER_H
&gt; #include &lt;iostream&gt;
&gt; 
&gt; // Non-member functions:
&gt; class Integer { 
&gt;   long i;
&gt; public:
&gt;   Integer(long ll = 0) : i(ll) {}
&gt;   // Operators that create new, modified value:
&gt;   friend const Integer
&gt;     operator+(const Integer&amp; left,
&gt;               const Integer&amp; right);
&gt;   friend const Integer
&gt;     operator-(const Integer&amp; left,
&gt;               const Integer&amp; right);
&gt;   friend const Integer
&gt;     operator*(const Integer&amp; left,
&gt;               const Integer&amp; right);
&gt;   friend const Integer
&gt;     operator/(const Integer&amp; left,
&gt;               const Integer&amp; right);
&gt;   friend const Integer
&gt;     operator%(const Integer&amp; left,
&gt;               const Integer&amp; right);
&gt;   friend const Integer
&gt;     operator^(const Integer&amp; left,
&gt;               const Integer&amp; right);
&gt;   friend const Integer
&gt;     operator&amp;(const Integer&amp; left,
&gt;               const Integer&amp; right);
&gt;   friend const Integer
&gt;     operator|(const Integer&amp; left,
&gt;               const Integer&amp; right);
&gt;   friend const Integer
&gt;     operator&lt;&lt;(const Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   friend const Integer
&gt;     operator&gt;&gt;(const Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   // Assignments modify &amp; return lvalue:
&gt;   friend Integer&amp;
&gt;     operator+=(Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   friend Integer&amp;
&gt;     operator-=(Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   friend Integer&amp;
&gt;     operator*=(Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   friend Integer&amp;
&gt;     operator/=(Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   friend Integer&amp;
&gt;     operator%=(Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   friend Integer&amp;
&gt;     operator^=(Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   friend Integer&amp;
&gt;     operator&amp;=(Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   friend Integer&amp;
&gt;     operator|=(Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   friend Integer&amp;
&gt;     operator&gt;&gt;=(Integer&amp; left,
&gt;                 const Integer&amp; right);
&gt;   friend Integer&amp;
&gt;     operator&lt;&lt;=(Integer&amp; left,
&gt;                 const Integer&amp; right);
&gt;   // Conditional operators return true/false:
&gt;   friend int
&gt;     operator==(const Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   friend int
&gt;     operator!=(const Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   friend int
&gt;     operator&lt;(const Integer&amp; left,
&gt;               const Integer&amp; right);
&gt;   friend int
&gt;     operator&gt;(const Integer&amp; left,
&gt;               const Integer&amp; right);
&gt;   friend int
&gt;     operator&lt;=(const Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   friend int
&gt;     operator&gt;=(const Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   friend int
&gt;     operator&amp;&amp;(const Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   friend int
&gt;     operator||(const Integer&amp; left,
&gt;                const Integer&amp; right);
&gt;   // Write the contents to an ostream:
&gt;   void print(std::ostream&amp; os) const { os &lt;&lt; i; }
&gt; }; 
&gt; #endif // INTEGER_H ///:~

&gt; //: C12:Integer.cpp {O}
&gt; // Implementation of overloaded operators
&gt; #include "Integer.h"
&gt; #include "../require.h"
&gt; 
&gt; const Integer
&gt;   operator+(const Integer&amp; left,
&gt;             const Integer&amp; right) {
&gt;   return Integer(left.i + right.i);
&gt; }
&gt; const Integer
&gt;   operator-(const Integer&amp; left,
&gt;             const Integer&amp; right) {
&gt;   return Integer(left.i - right.i);
&gt; }
&gt; const Integer
&gt;   operator*(const Integer&amp; left,
&gt;             const Integer&amp; right) {
&gt;   return Integer(left.i * right.i);
&gt; }
&gt; const Integer
&gt;   operator/(const Integer&amp; left,
&gt;             const Integer&amp; right) {
&gt;   require(right.i != 0, "divide by zero");
&gt;   return Integer(left.i / right.i);
&gt; }
&gt; const Integer
&gt;   operator%(const Integer&amp; left,
&gt;             const Integer&amp; right) {
&gt;   require(right.i != 0, "modulo by zero");
&gt;   return Integer(left.i % right.i);
&gt; }
&gt; const Integer
&gt;   operator^(const Integer&amp; left,
&gt;             const Integer&amp; right) {
&gt;   return Integer(left.i ^ right.i);
&gt; }
&gt; const Integer
&gt;   operator&amp;(const Integer&amp; left,
&gt;             const Integer&amp; right) {
&gt;   return Integer(left.i &amp; right.i);
&gt; }
&gt; const Integer
&gt;   operator|(const Integer&amp; left,
&gt;             const Integer&amp; right) {
&gt;   return Integer(left.i | right.i);
&gt; }
&gt; const Integer
&gt;   operator&lt;&lt;(const Integer&amp; left,
&gt;              const Integer&amp; right) {
&gt;   return Integer(left.i &lt;&lt; right.i);
&gt; }
&gt; const Integer
&gt;   operator&gt;&gt;(const Integer&amp; left,
&gt;              const Integer&amp; right) {
&gt;   return Integer(left.i &gt;&gt; right.i);
&gt; }
&gt; // Assignments modify &amp; return lvalue:
&gt; Integer&amp; operator+=(Integer&amp; left,
&gt;                     const Integer&amp; right) {
&gt;    if(&amp;left == &amp;right) {/* self-assignment */}
&gt;    left.i += right.i;
&gt;    return left;
&gt; }
&gt; Integer&amp; operator-=(Integer&amp; left,
&gt;                     const Integer&amp; right) {
&gt;    if(&amp;left == &amp;right) {/* self-assignment */}
&gt;    left.i -= right.i;
&gt;    return left;
&gt; }
&gt; Integer&amp; operator*=(Integer&amp; left,
&gt;                     const Integer&amp; right) {
&gt;    if(&amp;left == &amp;right) {/* self-assignment */}
&gt;    left.i *= right.i;
&gt;    return left;
&gt; }
&gt; Integer&amp; operator/=(Integer&amp; left,
&gt;                     const Integer&amp; right) {
&gt;    require(right.i != 0, "divide by zero");
&gt;    if(&amp;left == &amp;right) {/* self-assignment */}
&gt;    left.i /= right.i;
&gt;    return left;
&gt; }
&gt; Integer&amp; operator%=(Integer&amp; left,
&gt;                     const Integer&amp; right) {
&gt;    require(right.i != 0, "modulo by zero");
&gt;    if(&amp;left == &amp;right) {/* self-assignment */}
&gt;    left.i %= right.i;
&gt;    return left;
&gt; }
&gt; Integer&amp; operator^=(Integer&amp; left,
&gt;                     const Integer&amp; right) {
&gt;    if(&amp;left == &amp;right) {/* self-assignment */}
&gt;    left.i ^= right.i;
&gt;    return left;
&gt; }
&gt; Integer&amp; operator&amp;=(Integer&amp; left,
&gt;                     const Integer&amp; right) {
&gt;    if(&amp;left == &amp;right) {/* self-assignment */}
&gt;    left.i &amp;= right.i;
&gt;    return left;
&gt; }
&gt; Integer&amp; operator|=(Integer&amp; left,
&gt;                     const Integer&amp; right) {
&gt;    if(&amp;left == &amp;right) {/* self-assignment */}
&gt;    left.i |= right.i;
&gt;    return left;
&gt; }
&gt; Integer&amp; operator&gt;&gt;=(Integer&amp; left,
&gt;                      const Integer&amp; right) {
&gt;    if(&amp;left == &amp;right) {/* self-assignment */}
&gt;    left.i &gt;&gt;= right.i;
&gt;    return left;
&gt; }
&gt; Integer&amp; operator&lt;&lt;=(Integer&amp; left,
&gt;                      const Integer&amp; right) {
&gt;    if(&amp;left == &amp;right) {/* self-assignment */}
&gt;    left.i &lt;&lt;= right.i;
&gt;    return left;
&gt; }
&gt; // Conditional operators return true/false:
&gt; int operator==(const Integer&amp; left,
&gt;                const Integer&amp; right) {
&gt;     return left.i == right.i;
&gt; }
&gt; int operator!=(const Integer&amp; left,
&gt;                const Integer&amp; right) {
&gt;     return left.i != right.i;
&gt; }
&gt; int operator&lt;(const Integer&amp; left,
&gt;               const Integer&amp; right) {
&gt;     return left.i &lt; right.i;
&gt; }
&gt; int operator&gt;(const Integer&amp; left,
&gt;               const Integer&amp; right) {
&gt;     return left.i &gt; right.i;
&gt; }
&gt; int operator&lt;=(const Integer&amp; left,
&gt;                const Integer&amp; right) {
&gt;     return left.i &lt;= right.i;
&gt; }
&gt; int operator&gt;=(const Integer&amp; left,
&gt;                const Integer&amp; right) {
&gt;     return left.i &gt;= right.i;
&gt; }
&gt; int operator&amp;&amp;(const Integer&amp; left,
&gt;                const Integer&amp; right) {
&gt;     return left.i &amp;&amp; right.i;
&gt; }
&gt; int operator||(const Integer&amp; left,
&gt;                const Integer&amp; right) {
&gt;     return left.i || right.i;
&gt; } ///:~

&gt; //: C12:IntegerTest.cpp
&gt; //{L} Integer
&gt; #include "Integer.h"
&gt; #include &lt;fstream&gt;
&gt; using namespace std;
&gt; ofstream out("IntegerTest.out");
&gt; 
&gt; void h(Integer&amp; c1, Integer&amp; c2) {
&gt;   // A complex expression:
&gt;   c1 += c1 * c2 + c2 % c1;
&gt;   #define TRY(OP) \
&gt;     out &lt;&lt; "c1 = "; c1.print(out); \
&gt;     out &lt;&lt; ", c2 = "; c2.print(out); \
&gt;     out &lt;&lt; ";  c1 " #OP " c2 produces "; \
&gt;     (c1 OP c2).print(out); \
&gt;     out &lt;&lt; endl;
&gt;   TRY(+) TRY(-) TRY(*) TRY(/)
&gt;   TRY(%) TRY(^) TRY(&amp;) TRY(|)
&gt;   TRY(&lt;&lt;) TRY(&gt;&gt;) TRY(+=) TRY(-=)
&gt;   TRY(*=) TRY(/=) TRY(%=) TRY(^=)
&gt;   TRY(&amp;=) TRY(|=) TRY(&gt;&gt;=) TRY(&lt;&lt;=)
&gt;   // Conditionals:
&gt;   #define TRYC(OP) \
&gt;     out &lt;&lt; "c1 = "; c1.print(out); \
&gt;     out &lt;&lt; ", c2 = "; c2.print(out); \
&gt;     out &lt;&lt; ";  c1 " #OP " c2 produces "; \
&gt;     out &lt;&lt; (c1 OP c2); \
&gt;     out &lt;&lt; endl;
&gt;   TRYC(&lt;) TRYC(&gt;) TRYC(==) TRYC(!=) TRYC(&lt;=)
&gt;   TRYC(&gt;=) TRYC(&amp;&amp;) TRYC(||)
&gt; } 
&gt; 
&gt; int main() {
&gt;   cout &lt;&lt; "friend functions" &lt;&lt; endl;
&gt;   Integer c1(47), c2(9);
&gt;   h(c1, c2);
&gt; } ///:~

&gt; //: C12:Byte.h
&gt; // Member overloaded operators
&gt; #ifndef BYTE_H
&gt; #define BYTE_H
&gt; #include "../require.h"
&gt; #include &lt;iostream&gt;
&gt; // Member functions (implicit "this"):
&gt; class Byte { 
&gt;   unsigned char b;
&gt; public:
&gt;   Byte(unsigned char bb = 0) : b(bb) {}
&gt;   // No side effects: const member function:
&gt;   const Byte
&gt;     operator+(const Byte&amp; right) const {
&gt;     return Byte(b + right.b);
&gt;   }
&gt;   const Byte
&gt;     operator-(const Byte&amp; right) const {
&gt;     return Byte(b - right.b);
&gt;   }
&gt;   const Byte
&gt;     operator*(const Byte&amp; right) const {
&gt;     return Byte(b * right.b);
&gt;   }
&gt;   const Byte
&gt;     operator/(const Byte&amp; right) const {
&gt;     require(right.b != 0, "divide by zero");
&gt;     return Byte(b / right.b);
&gt;   }
&gt;   const Byte
&gt;     operator%(const Byte&amp; right) const {
&gt;     require(right.b != 0, "modulo by zero");
&gt;     return Byte(b % right.b);
&gt;   }
&gt;   const Byte
&gt;     operator^(const Byte&amp; right) const {
&gt;     return Byte(b ^ right.b);
&gt;   }
&gt;   const Byte
&gt;     operator&amp;(const Byte&amp; right) const {
&gt;     return Byte(b &amp; right.b);
&gt;   }
&gt;   const Byte
&gt;     operator|(const Byte&amp; right) const {
&gt;     return Byte(b | right.b);
&gt;   }
&gt;   const Byte
&gt;     operator&lt;&lt;(const Byte&amp; right) const {
&gt;     return Byte(b &lt;&lt; right.b);
&gt;   }
&gt;   const Byte
&gt;     operator&gt;&gt;(const Byte&amp; right) const {
&gt;     return Byte(b &gt;&gt; right.b);
&gt;   }
&gt;   // Assignments modify &amp; return lvalue.
&gt;   // operator= can only be a member function:
&gt;   Byte&amp; operator=(const Byte&amp; right) {
&gt;     // Handle self-assignment:
&gt;     if(this == &amp;right) return *this;
&gt;     b = right.b;
&gt;     return *this;
&gt;   }
&gt;   Byte&amp; operator+=(const Byte&amp; right) {
&gt;     if(this == &amp;right) {/* self-assignment */}
&gt;     b += right.b;
&gt;     return *this;
&gt;   }
&gt;   Byte&amp; operator-=(const Byte&amp; right) {
&gt;     if(this == &amp;right) {/* self-assignment */}
&gt;     b -= right.b;
&gt;     return *this;
&gt;   }
&gt;   Byte&amp; operator*=(const Byte&amp; right) {
&gt;     if(this == &amp;right) {/* self-assignment */}
&gt;     b *= right.b;
&gt;     return *this;
&gt;   }
&gt;   Byte&amp; operator/=(const Byte&amp; right) {
&gt;     require(right.b != 0, "divide by zero");
&gt;     if(this == &amp;right) {/* self-assignment */}
&gt;     b /= right.b;
&gt;     return *this;
&gt;   }
&gt;   Byte&amp; operator%=(const Byte&amp; right) {
&gt;     require(right.b != 0, "modulo by zero");
&gt;     if(this == &amp;right) {/* self-assignment */}
&gt;     b %= right.b;
&gt;     return *this;
&gt;   }
&gt;   Byte&amp; operator^=(const Byte&amp; right) {
&gt;     if(this == &amp;right) {/* self-assignment */}
&gt;     b ^= right.b;
&gt;     return *this;
&gt;   }
&gt;   Byte&amp; operator&amp;=(const Byte&amp; right) {
&gt;     if(this == &amp;right) {/* self-assignment */}
&gt;     b &amp;= right.b;
&gt;     return *this;
&gt;   }
&gt;   Byte&amp; operator|=(const Byte&amp; right) {
&gt;     if(this == &amp;right) {/* self-assignment */}
&gt;     b |= right.b;
&gt;     return *this;
&gt;   }
&gt;   Byte&amp; operator&gt;&gt;=(const Byte&amp; right) {
&gt;     if(this == &amp;right) {/* self-assignment */}
&gt;     b &gt;&gt;= right.b;
&gt;     return *this;
&gt;   }
&gt;   Byte&amp; operator&lt;&lt;=(const Byte&amp; right) {
&gt;     if(this == &amp;right) {/* self-assignment */}
&gt;     b &lt;&lt;= right.b;
&gt;     return *this;
&gt;   }
&gt;   // Conditional operators return true/false:
&gt;   int operator==(const Byte&amp; right) const {
&gt;       return b == right.b;
&gt;   }
&gt;   int operator!=(const Byte&amp; right) const {
&gt;       return b != right.b;
&gt;   }
&gt;   int operator&lt;(const Byte&amp; right) const {
&gt;       return b &lt; right.b;
&gt;   }
&gt;   int operator&gt;(const Byte&amp; right) const {
&gt;       return b &gt; right.b;
&gt;   }
&gt;   int operator&lt;=(const Byte&amp; right) const {
&gt;       return b &lt;= right.b;
&gt;   }
&gt;   int operator&gt;=(const Byte&amp; right) const {
&gt;       return b &gt;= right.b;
&gt;   }
&gt;   int operator&amp;&amp;(const Byte&amp; right) const {
&gt;       return b &amp;&amp; right.b;
&gt;   }
&gt;   int operator||(const Byte&amp; right) const {
&gt;       return b || right.b;
&gt;   }
&gt;   // Write the contents to an ostream:
&gt;   void print(std::ostream&amp; os) const {
&gt;     os &lt;&lt; "0x" &lt;&lt; std::hex &lt;&lt; int(b) &lt;&lt; std::dec;
&gt;   }
&gt; }; 
&gt; #endif // BYTE_H ///:~

&gt; //: C12:ByteTest.cpp
&gt; #include "Byte.h"
&gt; #include &lt;fstream&gt;
&gt; using namespace std;
&gt; ofstream out("ByteTest.out");
&gt; 
&gt; void k(Byte&amp; b1, Byte&amp; b2) {
&gt;   b1 = b1 * b2 + b2 % b1;
&gt; 
&gt;   #define TRY2(OP) \
&gt;     out &lt;&lt; "b1 = "; b1.print(out); \
&gt;     out &lt;&lt; ", b2 = "; b2.print(out); \
&gt;     out &lt;&lt; ";  b1 " #OP " b2 produces "; \
&gt;     (b1 OP b2).print(out); \
&gt;     out &lt;&lt; endl;
&gt; 
&gt;   b1 = 9; b2 = 47;
&gt;   TRY2(+) TRY2(-) TRY2(*) TRY2(/)
&gt;   TRY2(%) TRY2(^) TRY2(&amp;) TRY2(|)
&gt;   TRY2(&lt;&lt;) TRY2(&gt;&gt;) TRY2(+=) TRY2(-=)
&gt;   TRY2(*=) TRY2(/=) TRY2(%=) TRY2(^=)
&gt;   TRY2(&amp;=) TRY2(|=) TRY2(&gt;&gt;=) TRY2(&lt;&lt;=)
&gt;   TRY2(=) // Assignment operator
&gt; 
&gt;   // Conditionals:
&gt;   #define TRYC2(OP) \
&gt;     out &lt;&lt; "b1 = "; b1.print(out); \
&gt;     out &lt;&lt; ", b2 = "; b2.print(out); \
&gt;     out &lt;&lt; ";  b1 " #OP " b2 produces "; \
&gt;     out &lt;&lt; (b1 OP b2); \
&gt;     out &lt;&lt; endl;
&gt; 
&gt;   b1 = 9; b2 = 47;
&gt;   TRYC2(&lt;) TRYC2(&gt;) TRYC2(==) TRYC2(!=) TRYC2(&lt;=)
&gt;   TRYC2(&gt;=) TRYC2(&amp;&amp;) TRYC2(||)
&gt; 
&gt;   // Chained assignment:
&gt;   Byte b3 = 92;
&gt;   b1 = b2 = b3;
&gt; }
&gt; 
&gt; int main() {
&gt;   out &lt;&lt; "member functions:" &lt;&lt; endl;
&gt;   Byte b1(47), b2(9);
&gt;   k(b1, b2);
&gt; } ///:~
</code></pre>
<p>可以看出，<strong>operator=</strong> 只允许是成员函数。稍后将对此进行解释。</p>
<p>请注意，所有赋值运算符都有检查自赋值的代码；这是一个通用准则。在某些情况下，这并非必要；例如，在使用 <strong>operator+=</strong> 时，您往往希望说 <strong>A+=A</strong> 并让它将 <strong>A</strong> 添加到自身。检查自分配的最重要的地方是 <strong>操作符=</strong>，因为对于复杂的对象，可能会出现灾难性的结果。(在某些情况下没有问题，但在编写 <strong>operator=</strong> 时应始终牢记这一点）。</p>
<p>前面两个示例中显示的所有运算符都被重载以处理单一类型。也可以重载运算符来处理混合类型，例如可以将苹果加到桔子上。不过，在开始详尽地重载运算符之前，应该先看看本章后面关于自动类型转换的章节。通常，在正确的地方进行类型转换可以节省大量的重载操作符。</p>
<h3 id="arguments--return-values--参数和返回值"><a class="header" href="#arguments--return-values--参数和返回值">Arguments &amp; return values  (参数和返回值)</a></h3>
<p>当您查看 <strong>OverloadingUnaryOperators.cpp</strong>、<strong>Integer.h</strong> 和 <strong>Byte.h</strong>，并看到所有不同的参数传递和返回方式时，起初可能会感到有些困惑。它们遵循的是一种逻辑模式，也是你在大多数选择中都要使用的模式。</p>
<ol>
<li>与任何函数参数一样，如果您只需要读取参数而不需要更改参数，则默认将其作为 <strong>const</strong> 引用传递。普通算术运算（如 <strong>+</strong> 和 <strong>-</strong> 等）和布尔运算不会更改参数，因此主要使用<strong>const</strong>引用传递。当函数是一个类成员时，这就意味着它是一个 <strong>const</strong> 成员函数。只有在运算符赋值（如 <strong>+=</strong>）和 <strong>运算符=</strong>（改变左侧参数）的情况下，左侧参数才不是常量，但它仍作为地址传入，因为它将被改变。</li>
<li>返回值的类型取决于操作符的预期含义。(如果操作符的作用是产生一个新值，则需要生成一个新对象作为返回值。例如，<strong>Integer::operator+</strong> 必须生成一个与操作数相加的 <strong>Integer</strong> 对象。该对象的返回值为<strong>const</strong>，因此结果不能作为 l 值修改。</li>
<li>所有赋值操作符都会修改 lvalue。为了使赋值结果能在链式表达式（如 <strong>a=b=c</strong>）中使用，我们希望返回一个指向刚刚修改过的 l 值的引用。但这个引用应该是<strong>常数</strong>还是非<strong>常数</strong>呢？虽然您是从左向右读取 <strong>a=b=c</strong>，但编译器是从右向左进行解析的，因此您并不被迫返回一个非<em><strong>const</strong>以支持赋值链。不过，有时人们确实希望能对刚刚赋值的对象执行操作，例如 <strong>(a=b).func( );</strong> 在对 <strong>a</strong> 赋值后，对 <strong>a</strong> 调用 <strong>func( )</strong>。因此，所有赋值操作符的返回值都应该是对 lvalue 的非</em><em>恒定</em>*引用。</li>
<li>对于逻辑运算符，每个人都希望最差能得到<strong>int</strong>，最好能得到<strong>bool</strong>。(在大多数编译器支持 C++ 内置<strong>bool</strong>之前开发的库将使用<strong>int</strong>或等效的<strong>typedef</strong>）。</li>
</ol>
<p>递增和递减运算符因为有前缀和后缀版本，所以会带来一个难题。这两个版本都会更改对象，因此不能将对象视为<strong>常数</strong>。前缀版本会返回对象更改后的值，因此我们希望返回更改后的对象。因此，使用前缀时，只需将 <em><strong>this</strong> 作为引用返回即可。后缀版本应该在值被更改之前返回该值，所以你不得不创建一个单独的对象来表示该值并返回它。因此，使用后缀时，如果要保留预期的含义，就必须按值返回。(注意，有时你会发现增量和减量运算符会返回一个</em><em>int</em><em>或</em><em>bool</em><em>来表示，例如，一个用于在列表中移动的对象是否处于列表的末尾）。现在的问题是：这些运算符应该返回</em><em>const</em><em>还是非</em><em>const</em>*？ 如果允许修改对象，并且有人写了 <strong>(++a).func( )</strong>，那么<strong>func( )</strong> 将对<strong>a</strong>本身执行操作，但如果写了 <strong>(a++).func( )</strong>，<strong>func( )</strong> 将对后缀<strong>operator++</strong> 返回的临时对象执行操作。临时对象是自动<strong>const</strong>的，因此编译器会对此进行标记，但为了保持一致，将它们都<strong>const</strong>可能更有意义，就像这里所做的那样。或者，你也可以选择将前缀版本设为非<em><strong>const</strong>，而将后缀设为</em><strong>const</strong>。由于您可能希望赋予递增和递减运算符多种含义，因此需要根据具体情况加以考虑。</p>
<h4 id="return-by-value-as-const--以常量形式按值返回"><a class="header" href="#return-by-value-as-const--以常量形式按值返回">Return by value as const  (以常量形式按值返回)</a></h4>
<p>以<strong>常数</strong>的形式按值返回，初看起来有点微妙，因此值得多解释一下。请看二进制<strong>操作符+</strong>。如果在 <strong>f(a+b)</strong> 这样的表达式中使用它, <strong>a+b</strong> 的结果就会成为一个临时对象，用于调用<strong>f( )</strong>。由于它是一个临时对象，因此自动<strong>为常数</strong>，所以无论您是否明确地将返回值设为<strong>为常数</strong>都没有影响。</p>
<p>不过，您也可以向 <strong>a+b</strong> 的返回值发送信息，而不只是将其传递给一个函数。例如，你可以说 <strong>(a+b).g( )</strong>，其中 <strong>g( )</strong> 是 <strong>Integer</strong> 的某个成员函数。将返回值设为 <strong>const</strong>，就表示只能调用 <strong>const</strong>成员函数来获取该返回值。这样做是<strong>const</strong>正确的，因为它避免了在对象中存储很可能丢失的有价值信息。</p>
<h4 id="the-return-optimization--返回值优化"><a class="header" href="#the-return-optimization--返回值优化">The return optimization  (返回值优化)</a></h4>
<p>在创建按值返回的新对象时，请注意所使用的形式。例如，在 <strong>operator+</strong> 中：</p>
<pre><code class="language-cpp">&gt; return Integer(left.i + right.i);
</code></pre>
<p>乍一看，这可能是一个 "构造函数的函数调用"，其实不然。语法是临时对象的语法；语句是 "创建一个临时的 <strong>Integer</strong> 对象并返回它"。因此，你可能会认为其结果与创建一个命名的本地对象并返回该对象是一样的。然而，这完全不同。如果换成如下语句</p>
<pre><code class="language-cpp">&gt; Integer tmp(left.i + right.i);
&gt; return tmp;
</code></pre>
<p>会发生三件事。首先，创建 <strong>tmp</strong> 对象，包括调用其构造函数。第二，复制构造函数将 <strong>tmp</strong> 复制到外部返回值的位置。第三，在作用域结束时调用 <strong>tmp</strong> 的析构函数。</p>
<p>相比之下，"返回临时 "方法的工作原理则完全不同。当编译器看到你这样做时，它知道你除了返回对象外，对它所创建的对象没有其他需要。编译器会利用这一点，直接将对象构建到外部返回值的位置。这只需要调用一次普通的构造函数（不需要复制构造函数），也不需要调用析构函数，因为你实际上从未创建过本地对象。因此，虽然除了程序员的意识外，它不需要任何代价，但效率却大大提高了。这通常被称为_返回值优化_。</p>
<h3 id="unusual-operators--不寻常的操作符"><a class="header" href="#unusual-operators--不寻常的操作符">Unusual operators  (不寻常的操作符)</a></h3>
<p>还有几个操作符的重载语法略有不同。</p>
<p>下标 <strong>operator[ ]</strong> 必须是成员函数，并且需要一个参数。由于 <strong>operator[ ]</strong> 意味着它所调用的对象就像一个数组，所以你经常会从这个操作符返回一个引用，这样它就可以方便地用在等号的左边。这个运算符通常会被重载；你将在本书的其余部分看到示例。</p>
<p>操作符 <strong>new</strong> 和 <strong>delete</strong> 控制动态存储器分配，可以多种不同方式重载。本主题将在第 13 章中介绍。</p>
<h4 id="operator-comma-操作符逗号"><a class="header" href="#operator-comma-操作符逗号">Operator comma (操作符逗号)</a></h4>
<p>当逗号操作符出现在逗号定义类型的对象旁边时，就会被调用。但是，"<strong>操作符,</strong>"不会在函数参数列表中调用，只会在用逗号分隔的对象中调用。这个运算符似乎并没有太多实际用途；它出现在语言中是为了保持一致性。下面的示例展示了逗号出现在对象之前和之后时，如何调用逗号函数：</p>
<pre><code class="language-cpp">&gt; //: C12:OverloadingOperatorComma.cpp
&gt; #include &lt;iostream&gt;
&gt; using namespace std;
&gt; 
&gt; class After {
&gt; public:
&gt;   const After&amp; operator,(const After&amp;) const {
&gt;     cout &lt;&lt; "After::operator,()" &lt;&lt; endl;
&gt;     return *this;
&gt;   }
&gt; };
&gt; 
&gt; class Before {};
&gt; 
&gt; Before&amp; operator,(int, Before&amp; b) {
&gt;   cout &lt;&lt; "Before::operator,()" &lt;&lt; endl;
&gt;   return b;
&gt; }
&gt; 
&gt; int main() {
&gt;   After a, b;
&gt;   a, b;  // Operator comma called
&gt; 
&gt;   Before c;
&gt;   1, c;  // Operator comma called
&gt; } ///:~
</code></pre>
<p>全局函数允许将逗号放在相关对象之前。所示用法相当隐晦，值得商榷。虽然您可能会在更复杂的表达式中使用逗号分隔列表，但在大多数情况下，这种用法都过于隐晦。</p>
<h4 id="operator---操作符---"><a class="header" href="#operator---操作符---">Operator-&gt;  (操作符-&gt;  )</a></h4>
<p>**操作符-&gt;**通常用于将一个对象显示为指针。由于这种对象比一般指针具有更多的 "智能"，因此通常被称为_智能指针_。如果你想将一个类 "包裹 "在指针周围，以确保指针的安全，或者在_iterator_（一种在其他对象的_collection_ /<em>container</em>（集合/容器）中移动并一次选择一个的对象，而不直接访问容器的实现）的常用用法中，这种指针尤其有用。(你经常会在类库中发现容器和迭代器，如本书第 2 卷中介绍的标准 C++ 库）。</p>
<p>指针解除引用操作符必须是成员函数。指针反引用操作符还有一些非典型的限制条件：它必须返回一个也有指针反引用操作符的对象（或对象引用），或者必须返回一个指针，用来选择指针反引用操作符箭头指向的对象。下面是一个简单的例子：</p>
<pre><code class="language-cpp">&gt; //: C12:SmartPointer.cpp
&gt; #include &lt;iostream&gt;
&gt; #include &lt;vector&gt;
&gt; #include "../require.h"
&gt; using namespace std;
&gt; 
&gt; class Obj {
&gt;   static int i, j;
&gt; public:
&gt;   void f() const { cout &lt;&lt; i++ &lt;&lt; endl; }
&gt;   void g() const { cout &lt;&lt; j++ &lt;&lt; endl; }
&gt; };
&gt; 
&gt; // Static member definitions:
&gt; int Obj::i = 47;
&gt; int Obj::j = 11;
&gt; 
&gt; // Container:
&gt; class ObjContainer {
&gt;   vector&lt;Obj*&gt; a;
&gt; public:
&gt;   void add(Obj* obj) { a.push_back(obj); }
&gt;   friend class SmartPointer;
&gt; };
&gt; 
&gt; class SmartPointer {
&gt;   ObjContainer&amp; oc;
&gt;   int index;
&gt; public:
&gt;   SmartPointer(ObjContainer&amp; objc) : oc(objc) {
&gt;     index = 0;
&gt;   }
&gt;   // Return value indicates end of list:
&gt;   bool operator++() { // Prefix
&gt;     if(index &gt;= oc.a.size()) return false;
&gt;     if(oc.a[++index] == 0) return false;
&gt;     return true;
&gt;   }
&gt;   bool operator++(int) { // Postfix
&gt;     return operator++(); // Use prefix version
&gt;   }
&gt;   Obj* operator-&gt;() const {
&gt;     require(oc.a[index] != 0, "Zero value "
&gt;       "returned by SmartPointer::operator-&gt;()");
&gt;     return oc.a[index];
&gt;   }
&gt; };
&gt; 
&gt; int main() {
&gt;   const int sz = 10;
&gt;   Obj o[sz];
&gt;   ObjContainer oc;
&gt;   for(int i = 0; i &lt; sz; i++)
&gt;     oc.add(&amp;o[i]); // Fill it up
&gt;   SmartPointer sp(oc); // Create an iterator
&gt;   do {
&gt;     sp-&gt;f(); // Pointer dereference operator call
&gt;     sp-&gt;g();
&gt;   } while(sp++);
&gt; } ///:~
</code></pre>
<p>类 <strong>Obj</strong> 定义了本程序中的操作对象。函数 <strong>f( )</strong> 和 <strong>g( )</strong> 只是使用 <strong>static</strong> 数据成员打印出有趣的值。这些对象的指针通过 <strong>add( )</strong> 函数存储在<strong>ObjContainer</strong>类型的容器中。<strong>ObjContainer</strong>看起来就像一个指针数组，但你会发现没有办法将指针再取出来。不过，<strong>SmartPointer</strong> 被声明为一个<strong>友</strong>类，因此它有权查看容器内部。<strong>SmartPointer</strong>类看起来非常像一个智能指针--你可以使用<strong>operator++</strong>（你也可以定义一个<strong>operator- -</strong>）向前移动它，它不会超过它所指向的容器的末端，并且（通过指针解除引用操作符）产生它所指向的值。请注意，<strong>SmartPointer</strong> 是为其创建的容器定制的；与普通指针不同，没有 "通用 "的智能指针。你将在本书最后一章和第 2 卷（可从 <em>www.BruceEckel.com</em> 下载）中了解到更多关于被称为 "迭代器 "的智能指针的知识。</p>
<p>在<strong>main()</strong> 中，一旦容器<strong>oc</strong>被<strong>Obj</strong>对象填满，就会创建一个<strong>SmartPointer sp</strong>。智能指针调用发生在表达式中：</p>
<pre><code class="language-cpp">&gt; sp-&gt;f(); // Smart pointer calls
&gt; sp-&gt;g(); 
</code></pre>
<p>在这里，尽管<strong>sp</strong>实际上没有<strong>f( )</strong> 和<strong>g( )</strong> 成员函数，但指针解除引用操作符会自动为<strong>SmartPointer::operator-&gt;<strong>返回的</strong>Obj</strong>*调用这些函数。编译器会执行所有检查以确保函数调用正常工作。</p>
<p>虽然指针取消引用操作符的基本机制比其他操作符更复杂，但其目标是完全相同的：为类的用户提供更方便的语法。</p>
<h4 id="a-nested-iterator--嵌套迭代器"><a class="header" href="#a-nested-iterator--嵌套迭代器">A nested iterator  (嵌套迭代器)</a></h4>
<p>更常见的情况是，"智能指针 "或 "迭代器 "类嵌套在它所服务的类中。前面的示例可以重写，将 <strong>SmartPointer</strong> 嵌套在 <strong>ObjContainer</strong> 内，就像这样：</p>
<pre><code class="language-cpp">&gt; //: C12:NestedSmartPointer.cpp
&gt; #include &lt;iostream&gt;
&gt; #include &lt;vector&gt;
&gt; #include "../require.h"
&gt; using namespace std;
&gt; 
&gt; class Obj {
&gt;   static int i, j;
&gt; public:
&gt;   void f() { cout &lt;&lt; i++ &lt;&lt; endl; }
&gt;   void g() { cout &lt;&lt; j++ &lt;&lt; endl; }
&gt; };
&gt; 
&gt; // Static member definitions:
&gt; int Obj::i = 47;
&gt; int Obj::j = 11;
&gt; 
&gt; // Container:
&gt; class ObjContainer {
&gt;   vector&lt;Obj*&gt; a;
&gt; public:
&gt;   void add(Obj* obj) { a.push_back(obj); }
&gt;   class SmartPointer;
&gt;   friend class SmartPointer;
&gt;   class SmartPointer {
&gt;     ObjContainer&amp; oc;
&gt;     unsigned int index;
&gt;   public:
&gt;     SmartPointer(ObjContainer&amp; objc) : oc(objc) {
&gt;       index = 0;
&gt;     }
&gt;     // Return value indicates end of list:
&gt;     bool operator++() { // Prefix
&gt;       if(index &gt;= oc.a.size()) return false;
&gt;       if(oc.a[++index] == 0) return false;
&gt;       return true;
&gt;     }
&gt;     bool operator++(int) { // Postfix
&gt;       return operator++(); // Use prefix version
&gt;     }
&gt;     Obj* operator-&gt;() const {
&gt;       require(oc.a[index] != 0, "Zero value "
&gt;         "returned by SmartPointer::operator-&gt;()");
&gt;       return oc.a[index];
&gt;     }
&gt;   };
&gt;   // Function to produce a smart pointer that 
&gt;   // points to the beginning of the ObjContainer:
&gt;   SmartPointer begin() { 
&gt;     return SmartPointer(*this);
&gt;   }
&gt; };
&gt; 
&gt; int main() {
&gt;   const int sz = 10;
&gt;   Obj o[sz];
&gt;   ObjContainer oc;
&gt;   for(int i = 0; i &lt; sz; i++)
&gt;     oc.add(&amp;o[i]); // Fill it up
&gt;   ObjContainer::SmartPointer sp = oc.begin();
&gt;   do {
&gt;     sp-&gt;f(); // Pointer dereference operator call
&gt;     sp-&gt;g();
&gt;   } while(++sp);
&gt; } ///:~
</code></pre>
<p>除了类的实际嵌套外，这里只有两处不同。首先是在类的声明上，它可以是一个<strong>好友</strong>：</p>
<pre><code class="language-cpp">&gt; class SmartPointer;
&gt; friend SmartPointer;
</code></pre>
<p>编译器必须首先知道类的存在，然后才能告诉编译器它是一个 <strong>friend</strong> 类。</p>
<p>第二个不同之处在于<strong>ObjContainer</strong>成员函数<strong>begin( )</strong>，它会产生一个<strong>SmartPointer</strong>，指向<strong>ObjContainer</strong>序列的起始位置。虽然这只是一个方便的函数，但它的价值在于它遵循了标准 C++ 库中使用的部分形式。</p>
<h4 id="operator---操作符--"><a class="header" href="#operator---操作符--">Operator-&gt;*  (操作符-&gt;* *)</a></h4>
<p><strong>operator-&gt;</strong>* 是一个二进制操作符，其行为与所有其他二进制操作符相同。它适用于需要模仿前一章介绍的内置_pointer-to-member_语法行为的情况。</p>
<p>与 <strong>operator-&gt;</strong>* 一样，指针到成员的取消引用操作符通常与某种代表 "智能指针 "的对象一起使用，不过这里的示例会简单一些，以便理解。定义 <strong>operator-&gt;</strong>* 时的诀窍是，它必须返回一个对象，在调用 <strong>operator( )</strong> 时，可以调用该对象的参数来调用所调用的成员函数。</p>
<p>函数调用_ <strong>operator( )</strong> 必须是成员函数，它的独特之处在于允许任意数量的参数。它使你的对象看起来就像一个函数。虽然你可以定义多个具有不同参数的重载 <strong>operator( )</strong> 函数，但它通常用于只有一个操作的类型，或者至少是一个特别突出的操作。你将在第 2 卷中看到，标准 C++ 库使用函数调用操作符来创建 "函数对象"。</p>
<p>要创建<strong>operator-&gt;****，首先必须创建一个带有</strong>operator( )<strong>的类，该类就是</strong>operator-&gt;****将返回的对象类型。该类必须以某种方式捕获必要的信息，以便在调用 <strong>operator( )</strong> 时（这会自动发生），为对象取消引用成员指针。在下面的示例中，<strong>FunctionObject</strong> 构造函数捕获并存储了对象指针和成员函数指针，然后<strong>operator( )</strong> 使用这些指针进行实际的指针到成员调用：</p>
<pre><code class="language-cpp">&gt; //: C12:PointerToMemberOperator.cpp
&gt; #include &lt;iostream&gt;
&gt; using namespace std;
&gt; 
&gt; class Dog {
&gt; public:
&gt;   int run(int i) const { 
&gt;     cout &lt;&lt; "run\n";  
&gt;     return i; 
&gt;   }
&gt;   int eat(int i) const { 
&gt;      cout &lt;&lt; "eat\n";  
&gt;      return i; 
&gt;   }
&gt;   int sleep(int i) const { 
&gt;     cout &lt;&lt; "ZZZ\n"; 
&gt;     return i; 
&gt;   }
&gt;   typedef int (Dog::*PMF)(int) const;
&gt;   // operator-&gt;* must return an object 
&gt;   // that has an operator():
&gt;   class FunctionObject {
&gt;     Dog* ptr;
&gt;     PMF pmem;
&gt;   public:
&gt;     // Save the object pointer and member pointer
&gt;     FunctionObject(Dog* wp, PMF pmf) 
&gt;       : ptr(wp), pmem(pmf) { 
&gt;       cout &lt;&lt; "FunctionObject constructor\n";
&gt;     }
&gt;     // Make the call using the object pointer
&gt;     // and member pointer
&gt;     int operator()(int i) const {
&gt;       cout &lt;&lt; "FunctionObject::operator()\n";
&gt;       return (ptr-&gt;*pmem)(i); // Make the call
&gt;     }
&gt;   };
&gt;   FunctionObject operator-&gt;*(PMF pmf) { 
&gt;     cout &lt;&lt; "operator-&gt;*" &lt;&lt; endl;
&gt;     return FunctionObject(this, pmf);
&gt;   }
&gt; };
&gt;  
&gt; int main() {
&gt;   Dog w;
&gt;   Dog::PMF pmf = &amp;Dog::run;
&gt;   cout &lt;&lt; (w-&gt;*pmf)(1) &lt;&lt; endl;
&gt;   pmf = &amp;Dog::sleep;
&gt;   cout &lt;&lt; (w-&gt;*pmf)(2) &lt;&lt; endl;
&gt;   pmf = &amp;Dog::eat;
&gt;   cout &lt;&lt; (w-&gt;*pmf)(3) &lt;&lt; endl;
&gt; } ///:~
</code></pre>
<p><strong>Dog</strong> 有三个成员函数，它们都接受一个<strong>int</strong>参数并返回一个<strong>int</strong>。<strong>PMF</strong>是一个<strong>类型定义</strong>，用于简化指向<strong>Dog</strong>成员函数的成员指针的定义。</p>
<p><strong>FunctionObject</strong> 由 <strong>operator-&gt;</strong>* 创建并返回。请注意，<strong>operator-&gt;</strong>** 知道指针转成员调用的对象（<strong>this</strong>）和指针转成员，并将它们传递给存储值的 <strong>FunctionObject</strong> 构造函数。当 <strong>operator-&gt;</strong>* 被调用时，编译器会立即调用 <strong>operator( )</strong> 来获取 <strong>operator-&gt;</strong>* 的返回值，同时传递给 <strong>operator-&gt;</strong>* 的参数。**FunctionObject::operator()**接收参数，然后使用其存储的对象指针和成员指针取消引用 "真正的 "成员指针。</p>
<p>请注意，与 <strong>operator-&gt;</strong> 一样，您在这里所做的是将自己插入到 <strong>operator-&gt;</strong>* 的调用中间。这样，您就可以在需要时执行一些额外的操作。</p>
<p>这里实现的<strong>operator-&gt;****机制只适用于接受一个</strong>int<strong>参数并返回一个</strong>int<strong>的成员函数。这是有局限性的，但如果要为每种不同的可能性创建重载机制，似乎是一项令人望而却步的任务。幸运的是，C++的</strong>模板**机制（在本书最后一章和第2卷中有描述）就是为了处理这样的问题而设计的。</p>
<h3 id="operators-you-cant-overload---不能重载的运算符"><a class="header" href="#operators-you-cant-overload---不能重载的运算符">Operators you can’t overload  ( 不能重载的运算符)</a></h3>
<p>在可用操作集中，有些操作符是不能重载的。限制的一般原因是安全。如果这些操作符可以重载，就会在某种程度上危及或破坏安全机制，增加工作难度，或混淆现有做法。</p>
<ul>
<li>成员选择<strong>operator.</strong>。目前，圆点对类中的任何成员都有意义，但如果允许重载圆点，就不能以正常方式访问成员，而必须使用指针和箭头 <strong>operator-&gt;</strong>。</li>
<li>成员指针取消引用 <strong>operator.</strong>*，原因与 **operator.**相同。</li>
<li>没有指数运算符。最流行的选择是 Fortran 中的 <strong>operator</strong>**，但这引起了难以解析的问题。此外，C 语言没有幂运算符，所以 C++ 似乎也不需要，因为你总是可以执行函数调用。幂运算符会增加一个方便的符号，但不会增加新的语言功能，也不会增加编译器的复杂性。</li>
<li>没有用户定义的运算符。也就是说，你不能编造新的运算符，而这些运算符目前又不在运算符集中。问题的一部分在于如何确定优先级，问题的另一部分在于没有充分考虑必要的麻烦。</li>
<li>你不能改变先例规则。要记住这些规则已经够难的了，还得让别人来玩。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../TICPP/12/12.2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../TICPP/12/12.4.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../TICPP/12/12.2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../TICPP/12/12.4.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
